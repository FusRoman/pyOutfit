{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyOutfit","text":"<p>High-performance Python bindings for the Outfit orbit-determination engine. pyOutfit provides a thin, typed interface to the Rust core to perform initial orbit determination, manipulate orbital elements, ingest astrometric observations, and process large batches efficiently.</p>"},{"location":"#what-this-project-is","title":"What this project is","text":"<p>pyOutfit is a Python package that exposes the Rust Outfit crate through PyO3. It brings robust, numerically stable routines for orbit determination and observation handling to Python workflows while keeping the heavy computation in Rust. The design emphasizes reliability, performance, and a clean user-facing API that integrates well with scientific Python stacks.</p>"},{"location":"#purpose-and-scope","title":"Purpose and scope","text":"<p>The package focuses on initial orbit determination (IOD) based on the classical Gauss method, conversions between orbital element representations, ingestion of astrometric observations from multiple sources, and scalable batch processing. It is intended for researchers and engineers working on astrometry pipelines, moving-object detection, and orbit characterization.</p>"},{"location":"#core-capabilities","title":"Core capabilities","text":"<ul> <li>Initial Orbit Determination using the Gauss method, with configurable numerical tolerances and physical filters.</li> <li>Multiple orbital element families with conversions: Keplerian, Equinoctial, and Cometary.</li> <li>Observation ingestion from common astronomy formats and in-memory arrays with minimal overhead.</li> <li>Parallel batch execution for large datasets, with deterministic behavior via seed control.</li> <li>Observer management, including MPC-coded observatories and custom definitions.</li> <li>Typed Python interface with docstrings, type stubs, and consistent error mapping.</li> </ul>"},{"location":"#architecture-at-a-glance","title":"Architecture at a glance","text":"<ul> <li>Rust core (Outfit crate) implements numerical algorithms, ephemerides access, reference frame transformations, and data structures.</li> <li>Python bindings (PyO3) expose high-level classes and functions, keeping data copies and conversions to a minimum.</li> <li>Optional parallelism in the Rust layer leverages multi-core systems transparently to Python users.</li> <li>The interface is designed to be predictable and stable for integration into existing pipelines.</li> </ul>"},{"location":"#data-and-models","title":"Data and models","text":"<ul> <li>Orbital elements: Keplerian, Equinoctial, and Cometary families with consistent units and reference epochs.</li> <li>Observations: right ascension, declination, timing, and uncertainties, with support for degrees or radians ingestion paths.</li> <li>Reference frames and corrections: precession, nutation, aberration, and observer geometry are handled in the Rust core.</li> <li>Ephemerides: planetary positions are obtained from high-accuracy JPL series (e.g., DE440) via the Outfit crate.</li> </ul>"},{"location":"#observation-ingestion-and-batches","title":"Observation ingestion and batches","text":"<ul> <li>Single-trajectory and multi-trajectory ingestion are both supported.</li> <li>Batch containers group observations by trajectory identifier for efficient processing.</li> <li>Readers and adapters cover traditional astronomy formats (e.g., MPC 80-column and ADES XML) and tabular data sources (e.g., Parquet), alongside direct NumPy-based ingestion.</li> </ul>"},{"location":"#performance-and-reliability","title":"Performance and reliability","text":"<ul> <li>Numerical kernels run in Rust without the Python GIL, minimizing overhead.</li> <li>Parallel execution is opt-in to avoid contention on small datasets and can be toggled via configuration.</li> <li>Deterministic runs are available by providing a random seed when executing batch estimations.</li> <li>Errors from the Rust core are mapped to idiomatic Python exceptions with informative messages.</li> </ul>"},{"location":"#requirements-and-compatibility","title":"Requirements and compatibility","text":"<ul> <li>Python 3.12.</li> <li>A recent Rust toolchain matching the Outfit crate minimum supported version.</li> <li>Linux (POSIX) is the primary target platform for packaged distributions.</li> <li>The package is distributed with type information (py.typed) and Python type stubs.</li> </ul>"},{"location":"#project-status","title":"Project status","text":"<p>The project is in active development and aims for scientific correctness, clear documentation, and practical performance. The public Python API is designed to be stable where possible; incremental improvements and extensions are expected as the Rust core evolves.</p>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li>Python package overview: PyOutfit</li> <li>Observer definitions and utilities: Observer</li> <li>IOD parameters and configuration: IODParams</li> <li>Initial Orbit Determination (Gauss): IODGauss</li> <li>Observations and containers: Observations, Trajectories</li> <li>Orbital element types: Keplerian, Equinoctial, Cometary</li> <li>Pandas integration notes: Pandas Integration</li> </ul>"},{"location":"#heritage-and-licensing","title":"Heritage and licensing","text":"<p>pyOutfit builds on the Outfit Rust crate, which is a modern reimplementation of classical Fortran-based orbit determination approaches. The package is distributed under the CeCILL-C license. See the repository license file for details.</p>"},{"location":"installation/","title":"Installation","text":"<p>This page describes the recommended ways to install <code>py-outfit</code> and set up an isolated environment. The package ships pre-built wheels for Linux x86_64 (Python 3.12) and embeds a Rust extension module compiled from the Outfit core. If a wheel is not available for your platform, a local build from source will be attempted (Rust toolchain required).</p>"},{"location":"installation/#quick-start-pypi-pip","title":"Quick start (PyPI / pip)","text":"<p>If you already have a clean Python 3.12 environment (e.g. <code>venv</code> or <code>virtualenv</code>):</p> <pre><code>pip install --upgrade pip\npip install py-outfit\n</code></pre> <p>Verify your installation:</p> <pre><code>python -c \"import py_outfit as o; print(o.KeplerianElements)\"\n</code></pre> <p>Expected output is the class representation (not an error). You can also check the version:</p> <pre><code>python -c \"import importlib.metadata as m; print(m.version('py-outfit'))\"\n</code></pre>"},{"location":"installation/#using-pdm-recommended-for-reproducible-workflows","title":"Using PDM (recommended for reproducible workflows)","text":"<p>PDM manages isolated environments and keeps metadata in <code>pyproject.toml</code>.</p> <ol> <li>Install PDM (user-level):     <pre><code>pip install --upgrade pdm\n</code></pre></li> <li>Initialize a new project directory (or reuse an existing one):     <pre><code>pdm init\n</code></pre>     Follow the prompts (you can skip dependencies now).</li> <li>Add <code>py-outfit</code> as a dependency:     <pre><code>pdm add py-outfit\n</code></pre></li> <li>Run Python inside the managed environment:     <pre><code>pdm run python -c \"import py_outfit; print(py_outfit.SECONDS_PER_DAY)\"\n</code></pre></li> </ol> <p>List current dependencies:</p> <pre><code>pdm list\n</code></pre>"},{"location":"installation/#using-conda-mamba","title":"Using Conda / Mamba","text":"<p>You can consume the PyPI wheel from within a Conda environment. Ensure the environment uses Python 3.12 so that the published wheel matches.</p> <ol> <li>Create and activate the environment (use <code>mamba</code> if available for speed):     <pre><code>conda create -n outfit-env python=3.12 -y\nconda activate outfit-env\n</code></pre></li> <li>Install via pip inside the environment:     <pre><code>pip install --upgrade pip\npip install py-outfit\n</code></pre></li> <li>Test:     <pre><code>python -c \"import py_outfit as o; print(o.GAUSS_GRAV)\"\n</code></pre></li> </ol> <p>If you need scientific stack packages (NumPy, Pandas, Astropy) with Conda optimizations, you can pre-install them:</p> <pre><code>conda install numpy pandas astropy pyarrow -y\npip install py-outfit\n</code></pre>"},{"location":"installation/#source-build-fallback","title":"Source build (fallback)","text":"<p>If your platform lacks a pre-built wheel, <code>pip</code> will build from source. Requirements:</p> <ul> <li>Rust toolchain (stable, matching the crate <code>rust-version</code> requirement).</li> <li>Build tools (e.g., <code>gcc</code>, <code>make</code>, and Python headers). On Debian/Ubuntu:   <pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential pkg-config python3-dev\n</code></pre></li> </ul> <p>Then:</p> <pre><code>pip install --upgrade pip maturin\npip install py-outfit --no-binary py-outfit\n</code></pre> <p>You can also clone the repository and build in-place:</p> <pre><code>git clone https://github.com/FusRoman/pyOutfit.git\ncd pyOutfit\npip install .\n</code></pre>"},{"location":"installation/#verifying-functionality","title":"Verifying functionality","text":"<p>Minimal smoke test to perform a trivial object creation (no external ephemerides download required for this step):</p> <pre><code>python - &lt;&lt;'PY'\nimport py_outfit as o\nke = o.KeplerianElements(\n     a=2.5,      # semi-major axis (AU)\n     e=0.1,      # eccentricity\n     i=0.2,      # inclination (rad)\n     omega=1.0,  # argument of perihelion (rad)\n     Omega=0.5,  # longitude of ascending node (rad)\n     M=0.0       # mean anomaly (rad)\n)\nprint(\"KeplerianElements a:\", ke.a)\nPY\n</code></pre> <p>If this runs without error, the Rust extension is correctly loaded.</p>"},{"location":"installation/#selecting-a-parallel-strategy","title":"Selecting a parallel strategy","text":"<p>Parallel features are enabled in the underlying Rust crate. No extra Python-side configuration is required. If you process large batches and want deterministic behavior across runs, pass a seed where exposed by batch APIs (see <code>estimate_all_orbits</code>).</p>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<pre><code>pip install --upgrade py-outfit\n</code></pre> <p>With PDM:</p> <pre><code>pdm update py-outfit\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<pre><code>pip uninstall py-outfit\n</code></pre> <p>Or in PDM:</p> <pre><code>pdm remove py-outfit\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>Missing wheel / build fails:   Ensure Rust is installed (<code>curl https://sh.rustup.rs -sSf | sh</code>) and that <code>rustc --version</code> meets or exceeds the crate requirement. Install system build dependencies (<code>build-essential</code> or equivalents).</p> <p>ImportError: cannot open shared object file:   Check that you are not mixing architectures (e.g., installing in a system Python but running inside Conda). Reinstall inside the same environment that runs Python.</p> <p>Segfault or crash on import:   Remove conflicting old builds: <code>pip uninstall py-outfit -y</code> then reinstall. Ensure only one version of the extension (<code>py_outfit*.so</code>) exists in the site-packages path.</p> <p>Ephemerides download issues:   The first call that triggers JPL ephemerides access may fetch data. Ensure network access is available, or pre-populate cache directories according to the Outfit core documentation.</p> <p>If problems persist, open an issue with: Python version, platform, <code>pip show py-outfit</code>, and the full install log (add <code>-vv</code> to pip commands for verbosity).</p>"},{"location":"installation/#next-steps","title":"Next steps","text":"<p>Proceed to the API reference or the tutorials (e.g., Initial Orbit Determination) once installation is confirmed.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart shows the smallest end-to-end example: create an environment, define (or fetch) an observer, ingest three astrometric observations for a single trajectory, and run a Gauss Initial Orbit Determination (IOD) to obtain a preliminary orbit.</p> <p>If you have not installed the package yet, see the Installation page first.</p>"},{"location":"quickstart/#1-import-and-environment","title":"1. Import and environment","text":"<p>The environment holds ephemerides and the astrometric error model. The first call may trigger a download of planetary ephemerides (JPL DE440) depending on cache state.</p> Environment initialization<pre><code>from py_outfit import PyOutfit\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")  # (ephemerides_id, error_model)\n</code></pre>"},{"location":"quickstart/#2-define-or-fetch-an-observer","title":"2. Define or fetch an observer","text":"<p>You can supply your own geodetic coordinates or use an MPC code if available. Elevation is expected in kilometers.</p> Observer creation<pre><code>from py_outfit import Observer\n\nobserver = Observer(\n    longitude=12.345,  # degrees East\n    latitude=-5.0,  # degrees North\n    elevation=1.5,  # kilometers\n    name=\"DemoSite\",\n    ra_accuracy=None,\n    dec_accuracy=None,\n)\nenv.add_observer(observer)\n\n# Alternatively using MPC code:\n# observer = env.get_observer_from_mpc_code(\"I41\")\n</code></pre>"},{"location":"quickstart/#3-prepare-a-minimal-observation-set","title":"3. Prepare a minimal observation set","text":"<p>We create three observations (the minimum for Gauss IOD) at distinct times. Use either the degree ingestion path (shown) or radians. Times are MJD(TT). Uncertainties are 1-sigma values (arcseconds in the degree path).</p> Setup small data<pre><code>import numpy as np\n\ntrajectory_id = np.array([0, 0, 0], dtype=np.uint32)  # single trajectory with ID 0\nra_deg = np.array(\n    [\n        20.9191548,\n        19.8927380,\n        18.2218784,\n    ]\n)  # Right Ascension in degrees\ndec_deg = np.array(\n    [\n        20.0550441,\n        20.2977473,\n        20.7096409,\n    ]\n)  # Declination in degrees\nmjd_tt = np.array(\n    [\n        58789.13709704,\n        58793.19047664,\n        58801.28714334,\n    ]\n)  # Observation epochs (TT)\n\nerr_ra_arcsec = 0.5  # uniform RA uncertainty\nerr_dec_arcsec = 0.5  # uniform Dec uncertainty\n</code></pre>"},{"location":"quickstart/#4-build-a-trajectoryset-and-extract-the-single-trajectory","title":"4. Build a TrajectorySet and extract the single trajectory","text":"<p>The TrajectorySet groups observations by ID. Even for one object it is the simplest way to obtain an <code>Observations</code> handle that exposes <code>estimate_best_orbit</code>.</p> Push data into a trajectory container<pre><code>from py_outfit import TrajectorySet\n\ntraj_set = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg.astype(float),\n    dec_deg.astype(float),\n    float(err_ra_arcsec),\n    float(err_dec_arcsec),\n    mjd_tt.astype(float),\n    observer,\n)\n\nobs = traj_set[0]  # Observations wrapper for trajectory ID 0\nprint(\"Number of observations:\", len(obs))\n</code></pre>"},{"location":"quickstart/#5-configure-iod-parameters","title":"5. Configure IOD parameters","text":"<p>Use the builder to tweak only what you need. Here we disable noise realizations for determinism and cap the search space for speed.</p> IOD Parameter configuration<pre><code>from py_outfit import IODParams\n\nparams = (\n    IODParams.builder()\n    .n_noise_realizations(0)  # purely geometric Gauss solve\n    .max_triplets(50)  # limit combinatorial expansion\n    .build()\n)\n</code></pre>"},{"location":"quickstart/#6-run-gauss-iod-for-the-single-trajectory","title":"6. Run Gauss IOD for the single trajectory","text":"<p><code>estimate_best_orbit</code> returns a <code>(GaussResult, rms)</code> pair. The RMS is an internal quality metric (angular residual scale).</p> Initial orbit determination<pre><code>gauss_result, rms = obs.estimate_best_orbit(env, params, seed=42)\nprint(\"RMS:\", rms)\nprint(\"Elements family:\", gauss_result.elements_type())\n</code></pre>"},{"location":"quickstart/#7-inspect-the-resulting-orbital-elements","title":"7. Inspect the resulting orbital elements","text":"<p>Depending on internal selection, a Keplerian, Equinoctial, or Cometary set is produced. Access helpers return <code>None</code> when the family does not match.</p> inspect results<pre><code>kep = gauss_result.keplerian()\nif kep is not None:\n    print(\"Semi-major axis (AU):\", kep.semi_major_axis)\n    print(\"Eccentricity:\", kep.eccentricity)\n    print(\"Inclination (rad):\", kep.inclination)\nelse:\n    eq = gauss_result.equinoctial()\n    if eq is not None:\n        print(\"Equinoctial h,k:\", eq.h, eq.k)\n    else:\n        com = gauss_result.cometary()\n        print(\"Cometary perihelion distance (AU):\", com.perihelion_distance)\n</code></pre>"},{"location":"quickstart/#8-full-minimal-script-copy-run","title":"8. Full minimal script (copy &amp; run)","text":"Full quickstart script (copy and past)<pre><code>from py_outfit import PyOutfit\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")  # (ephemerides_id, error_model)\n\nfrom py_outfit import Observer\n\nobserver = Observer(\n    longitude=12.345,  # degrees East\n    latitude=-5.0,  # degrees North\n    elevation=1.5,  # kilometers\n    name=\"DemoSite\",\n    ra_accuracy=None,\n    dec_accuracy=None,\n)\nenv.add_observer(observer)\n\n# Alternatively using MPC code:\n# observer = env.get_observer_from_mpc_code(\"I41\")\n\nimport numpy as np\n\ntrajectory_id = np.array([0, 0, 0], dtype=np.uint32)  # single trajectory with ID 0\nra_deg = np.array(\n    [\n        20.9191548,\n        19.8927380,\n        18.2218784,\n    ]\n)  # Right Ascension in degrees\ndec_deg = np.array(\n    [\n        20.0550441,\n        20.2977473,\n        20.7096409,\n    ]\n)  # Declination in degrees\nmjd_tt = np.array(\n    [\n        58789.13709704,\n        58793.19047664,\n        58801.28714334,\n    ]\n)  # Observation epochs (TT)\n\nerr_ra_arcsec = 0.5  # uniform RA uncertainty\nerr_dec_arcsec = 0.5  # uniform Dec uncertainty\n\nfrom py_outfit import TrajectorySet\n\ntraj_set = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg.astype(float),\n    dec_deg.astype(float),\n    float(err_ra_arcsec),\n    float(err_dec_arcsec),\n    mjd_tt.astype(float),\n    observer,\n)\n\nobs = traj_set[0]  # Observations wrapper for trajectory ID 0\nprint(\"Number of observations:\", len(obs))\n\nfrom py_outfit import IODParams\n\nparams = (\n    IODParams.builder()\n    .n_noise_realizations(0)  # purely geometric Gauss solve\n    .max_triplets(50)  # limit combinatorial expansion\n    .build()\n)\n\ngauss_result, rms = obs.estimate_best_orbit(env, params, seed=42)\nprint(\"RMS:\", rms)\nprint(\"Elements family:\", gauss_result.elements_type())\n\nkep = gauss_result.keplerian()\nif kep is not None:\n    print(\"Semi-major axis (AU):\", kep.semi_major_axis)\n    print(\"Eccentricity:\", kep.eccentricity)\n    print(\"Inclination (rad):\", kep.inclination)\nelse:\n    eq = gauss_result.equinoctial()\n    if eq is not None:\n        print(\"Equinoctial h,k:\", eq.h, eq.k)\n    else:\n        com = gauss_result.cometary()\n        print(\"Cometary perihelion distance (AU):\", com.perihelion_distance)\n</code></pre> <p>At the end of the run, typical console output looks like: <pre><code>Number of observations: 3\nRMS: 0.62            # angular residual scale (approx.)\nElements family: keplerian\nSemi-major axis (AU): 2.72084815\nEccentricity: 0.27511014\nInclination (rad): 0.27433785 (~15.7 deg)\n</code></pre></p> <p>Note: Exact numbers can vary slightly (last decimals) depending on platform, floating\u2011point rounding, and random seed (if noise realizations were enabled). Differences at the 1e-9\u20131e-12 level are normal.</p>"},{"location":"quickstart/#9-next-steps","title":"9. Next steps","text":"<p>Proceed to:</p> <ul> <li>Tutorials for batch processing and parameter tuning.</li> <li>API reference (<code>IODParams</code>, <code>GaussResult</code>, orbital element classes) for deeper control.</li> </ul> <p>If your first run downloads ephemerides, subsequent runs should start much faster.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the public Python API exposed by pyOutfit. It describes the main classes, their responsibilities, configuration options, data representations, and how results are structured. The focus is on clarity and practical use within astrometric and orbit-determination workflows.</p>"},{"location":"api/#what-you-will-find-here","title":"What you will find here","text":"<ul> <li>A guided description of the core classes that make up the user-facing API.</li> <li>The configuration surface for Initial Orbit Determination (IOD) and related numerical and physical filters.</li> <li>The data containers used to ingest, store, and iterate over observations and trajectory batches.</li> <li>The different orbital element families and how to interpret their fields and reference epochs.</li> <li>The observer model and ephemeris context needed by the solvers.</li> <li>Notes on performance, parallel execution, determinism, and error handling.</li> </ul>"},{"location":"api/#package-layout-python-names","title":"Package layout (Python names)","text":"<ul> <li>Environment and context: <code>PyOutfit</code> (ephemerides, error model, observatory registry).</li> <li>Observers: <code>Observer</code> (MPC-coded or custom definitions, geodetic parameters).</li> <li>IOD configuration: <code>IODParams</code> and its builder for numerical tolerances and execution mode.</li> <li>Observations and batches: <code>Observations</code> (per-trajectory), <code>TrajectorySet</code> (ID \u2192 observations mapping).</li> <li>IOD results: <code>GaussResult</code> (preliminary/corrected solution access, element extraction).</li> <li>Orbital elements: <code>KeplerianElements</code>, <code>EquinoctialElements</code>, <code>CometaryElements</code>.</li> <li>Pandas helpers: optional utilities for tabular ingestion and export.</li> </ul>"},{"location":"api/#conventions-and-units","title":"Conventions and units","text":"<ul> <li>Angles are expressed in radians internally. Degree ingestion is supported and converted on input.</li> <li>Times are Modified Julian Date (MJD), typically in the TT scale consistent with the ephemerides.</li> <li>Distances follow conventions of the underlying Rust core: astronomical units for orbital scales and kilometers for observer elevation.</li> <li>All public classes are typed; the package ships with type stubs and a <code>py.typed</code> marker for static analysis.</li> <li>Errors from the Rust core surface as Python <code>RuntimeError</code> with descriptive messages; error variants are flattened for batch results.</li> </ul>"},{"location":"api/#parallelism-and-determinism","title":"Parallelism and determinism","text":"<ul> <li>Parallel execution is opt-in and controlled through <code>IODParams</code>; it is designed for large batches.</li> <li>Deterministic runs can be achieved by providing a seed where supported (e.g., batch estimation pathways).</li> <li>Heavy numerical work executes outside the Python GIL, minimizing interpreter overhead.</li> </ul>"},{"location":"api/#navigation","title":"Navigation","text":"<ul> <li>Python package overview: py_outfit</li> <li>Observers and observatory registry: observer</li> <li>IOD configuration parameters: iod_params</li> <li>Gauss Initial Orbit Determination: iod_gauss</li> <li>Observations container: observations</li> <li>Trajectories and batch processing: trajectories</li> <li>Orbital element families:<ul> <li>Keplerian</li> <li>Equinoctial</li> <li>Cometary</li> </ul> </li> <li>Pandas integration notes: pandas_pyoutfit</li> </ul>"},{"location":"api/#stability-and-status","title":"Stability and status","text":"<p>The API is designed to be practical and predictable, with an emphasis on scientific correctness. While the project is still evolving, changes aim to preserve user-facing stability where feasible. Type information and documentation are maintained to ease integration into existing pipelines.</p>"},{"location":"api/iod_gauss/","title":"IODGauss","text":""},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult","title":"py_outfit.iod_gauss.GaussResult","text":"<p>Result of a Gauss Initial Orbit Determination (IOD) for a single object.</p> Variants <ul> <li><code>PrelimOrbit(OrbitalElements)</code> \u2014 result directly from the Gauss solution.</li> <li><code>CorrectedOrbit(OrbitalElements)</code> \u2014 result after the post-Gauss correction step.</li> </ul> See also <ul> <li><code>from_keplerian</code>, <code>from_equinoctial</code>, <code>from_cometary</code> \u2014 Build a result from a given element family.</li> <li><code>is_preliminary</code>, <code>is_corrected</code> \u2014 Stage predicates.</li> <li><code>elements_type</code> \u2014 <code>\"keplerian\" | \"equinoctial\" | \"cometary\"</code>.</li> <li><code>keplerian</code>, <code>equinoctial</code>, <code>cometary</code> \u2014 Typed extraction helpers (return <code>None</code> if mismatched).</li> <li><code>to_dict</code> \u2014 Structured dict view for serialization or logging.</li> </ul>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.from_keplerian","title":"from_keplerian  <code>classmethod</code>","text":"<pre><code>from_keplerian(\n    keplerian: KeplerianElements, corrected: Optional[bool] = ...\n) -&gt; GaussResult\n</code></pre> <p>Build a <code>GaussResult</code> from Keplerian elements.</p> RETURNS DESCRIPTION <code>GaussResult</code> <p>A <code>GaussResult</code> embedding the provided elements.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.from_equinoctial","title":"from_equinoctial  <code>classmethod</code>","text":"<pre><code>from_equinoctial(\n    equinoctial: EquinoctialElements, corrected: Optional[bool] = ...\n) -&gt; GaussResult\n</code></pre> <p>Build a <code>GaussResult</code> from Equinoctial elements.</p> RETURNS DESCRIPTION <code>GaussResult</code> <p>A <code>GaussResult</code> embedding the provided elements.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.from_cometary","title":"from_cometary  <code>classmethod</code>","text":"<pre><code>from_cometary(\n    cometary: CometaryElements, corrected: Optional[bool] = ...\n) -&gt; GaussResult\n</code></pre> <p>Build a <code>GaussResult</code> from Cometary elements.</p> RETURNS DESCRIPTION <code>GaussResult</code> <p>A <code>GaussResult</code> embedding the provided elements.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.is_corrected","title":"is_corrected","text":"<pre><code>is_corrected() -&gt; bool\n</code></pre> <p>Whether this result is the corrected stage.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> for <code>CorrectedOrbit</code>, <code>False</code> for <code>PrelimOrbit</code>.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.is_preliminary","title":"is_preliminary","text":"<pre><code>is_preliminary() -&gt; bool\n</code></pre> <p>Whether this result is the preliminary Gauss solution.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> for <code>PrelimOrbit</code>, <code>False</code> for <code>CorrectedOrbit</code>.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.elements_type","title":"elements_type","text":"<pre><code>elements_type() -&gt; Literal['keplerian', 'equinoctial', 'cometary']\n</code></pre> <p>Return the family of orbital elements stored inside.</p> RETURNS DESCRIPTION <code>Literal['keplerian', 'equinoctial', 'cometary']</code> <p>The family of orbital elements stored inside.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.keplerian","title":"keplerian","text":"<pre><code>keplerian() -&gt; Optional[KeplerianElements]\n</code></pre> <p>Extract Keplerian elements if present.</p> RETURNS DESCRIPTION <code>KeplerianElements | None</code> <p><code>KeplerianElements</code> if the underlying family is keplerian, else <code>None</code>.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.equinoctial","title":"equinoctial","text":"<pre><code>equinoctial() -&gt; Optional[EquinoctialElements]\n</code></pre> <p>Extract Equinoctial elements if present.</p> RETURNS DESCRIPTION <code>EquinoctialElements | None</code> <p><code>EquinoctialElements</code> if the underlying family is equinoctial, else <code>None</code>.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.cometary","title":"cometary","text":"<pre><code>cometary() -&gt; Optional[CometaryElements]\n</code></pre> <p>Extract Cometary elements if present.</p> RETURNS DESCRIPTION <code>CometaryElements | None</code> <p><code>CometaryElements</code> if the underlying family is cometary, else <code>None</code>.</p>"},{"location":"api/iod_gauss/#py_outfit.iod_gauss.GaussResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert the result to a structured Python dict.</p> Schema <ul> <li><code>\"stage\"</code>: <code>\"preliminary\"</code> | <code>\"corrected\"</code></li> <li><code>\"type\"</code>: <code>\"keplerian\"</code> | <code>\"equinoctial\"</code> | <code>\"cometary\"</code></li> <li><code>\"elements\"</code>: dict of concrete fields for the stored family:</li> <li>Keplerian: <code>reference_epoch</code>, <code>semi_major_axis</code>, <code>eccentricity</code>,     <code>inclination</code>, <code>ascending_node_longitude</code>, <code>periapsis_argument</code>, <code>mean_anomaly</code></li> <li>Equinoctial: <code>reference_epoch</code>, <code>semi_major_axis</code>,     <code>eccentricity_sin_lon</code>, <code>eccentricity_cos_lon</code>,     <code>tan_half_incl_sin_node</code>, <code>tan_half_incl_cos_node</code>, <code>mean_longitude</code></li> <li>Cometary: <code>reference_epoch</code>, <code>perihelion_distance</code>, <code>eccentricity</code>,     <code>inclination</code>, <code>ascending_node_longitude</code>, <code>periapsis_argument</code>, <code>true_anomaly</code></li> </ul> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A structured dict representation of the result.</p>"},{"location":"api/iod_params/","title":"IOD Parameters","text":""},{"location":"api/iod_params/#py_outfit.iod_params.IODParams","title":"py_outfit.iod_params.IODParams","text":"<pre><code>IODParams()\n</code></pre> <p>Configuration for Gauss Initial Orbit Determination (IOD).</p> Purpose <p>This configuration centralizes all tunable parameters used by the Gauss pipeline. It covers candidate triplet selection, Monte Carlo perturbations, physical and numerical filters, solver tolerances, and RMS evaluation. The objective is to allow fine-grained control over the Gauss IOD process in a single container object.</p> Pipeline overview <p>The pipeline proceeds in four main stages:</p> <ol> <li> <p>Triplet generation. Candidate observation triplets are constrained by <code>dt_min</code>, <code>dt_max_triplet</code>, and <code>optimal_interval_time</code>. Oversized datasets may be downsampled to <code>max_obs_for_triplets</code> before selection.</p> </li> <li> <p>Monte Carlo perturbation. Each triplet is expanded into multiple noisy copies (<code>n_noise_realizations</code>) drawn from Gaussian perturbations scaled by <code>noise_scale</code>.</p> </li> <li> <p>Orbit computation and filtering. Candidate orbits are produced by the Gauss solver and filtered by physical plausibility (<code>max_ecc</code>, <code>max_perihelion_au</code>, <code>r2_min_au</code>, <code>r2_max_au</code>, <code>min_rho2_au</code>) and numerical tolerances (<code>newton_eps</code>, <code>newton_max_it</code>, <code>root_imag_eps</code>, <code>aberth_max_iter</code>, <code>aberth_eps</code>, <code>kepler_eps</code>). A maximum of <code>max_tested_solutions</code> is retained.</p> </li> <li> <p>RMS evaluation. Candidates are scored by RMS residuals in a time window derived from <code>extf \u00d7 (triplet span)</code> and clamped to at least <code>dtmax</code>. The candidate with the lowest RMS is selected.</p> </li> </ol> Defaults <p>The default values are as follows (matching the Rust <code>Default</code> implementation).</p> <ol> <li> <p>Triplet / Monte Carlo parameters:</p> <ul> <li><code>n_noise_realizations</code> : 20</li> <li><code>noise_scale</code>          : 1.0</li> <li><code>extf</code>                 : -1.0   (negative = broad fallback window)</li> <li><code>dtmax</code>                : 30.0   (days)</li> <li><code>dt_min</code>               : 0.03   (days)</li> <li><code>dt_max_triplet</code>       : 150.0  (days)</li> <li><code>optimal_interval_time</code>: 20.0   (days)</li> <li><code>max_obs_for_triplets</code> : 100</li> <li><code>max_triplets</code>         : 10</li> <li><code>gap_max</code>              : 8/24   (days; 8 hours)</li> </ul> </li> <li> <p>Physical filters:</p> <ul> <li><code>max_ecc</code>           : 5.0</li> <li><code>max_perihelion_au</code> : 1.0e3</li> <li><code>min_rho2_au</code>       : 0.01   (AU)</li> </ul> </li> <li> <p>Heliocentric r2 bounds:</p> <ul> <li><code>r2_min_au</code> : 0.05   (AU)</li> <li><code>r2_max_au</code> : 200.0  (AU)</li> </ul> </li> <li> <p>Polynomial solver / numerics:</p> <ul> <li><code>aberth_max_iter</code> : 50</li> <li><code>aberth_eps</code>      : 1.0e-6</li> <li><code>kepler_eps</code>      : \u2248 2.22e-13 (1e3 \u00d7 machine epsilon)</li> <li><code>newton_eps</code>      : 1.0e-10</li> <li><code>newton_max_it</code>   : 50</li> <li><code>root_imag_eps</code>   : 1.0e-6</li> </ul> </li> <li> <p>Parallelization:</p> <ul> <li><code>batch_size</code> : 4  (only effective if compiled with parallel features)</li> </ul> </li> </ol> Notes <p>RMS evaluation window is computed as: <code>dt_window = (last \u2212 first) \u00d7 extf</code>, clamped so that <code>dt_window \u2265 dtmax</code>. If <code>extf &lt; 0</code>, a broad fallback window is used (typically a multiple of the dataset span).</p> <p>The parameter <code>min_rho2_au</code> applies a topocentric distance constraint at the central epoch to avoid near-observer pathologies.</p> <p>Bounds <code>r2_min_au \u2264 r2_max_au</code> provide plausibility constraints for the heliocentric distance when selecting roots of the degree-8 Gauss polynomial.</p> <p>Typical constraints are: <code>max_ecc \u2265 0</code>, <code>max_perihelion_au &gt; 0</code>, <code>min_rho2_au &gt; 0</code>, <code>aberth_max_iter \u2265 1</code>, <code>aberth_eps &gt; 0</code>, <code>kepler_eps &gt; 0</code>, <code>newton_eps &gt; 0</code>, <code>newton_max_it \u2265 1</code>, <code>root_imag_eps \u2265 0</code>, <code>max_tested_solutions \u2265 1</code>.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.n_noise_realizations","title":"n_noise_realizations  <code>property</code>","text":"<pre><code>n_noise_realizations: int\n</code></pre> <p>Number of Monte Carlo perturbations per original triplet. Default: 20.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.noise_scale","title":"noise_scale  <code>property</code>","text":"<pre><code>noise_scale: float\n</code></pre> <p>Scale applied to nominal RA/DEC uncertainties (1.0 \u21d2 nominal). Default: 1.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.extf","title":"extf  <code>property</code>","text":"<pre><code>extf: float\n</code></pre> <p>Extrapolation factor for the RMS evaluation window: <code>dt_window = (triplet span) \u00d7 extf</code>, then clamped so <code>dt_window \u2265 dtmax</code>. Negative values trigger a broad fallback window. Default: -1.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.dtmax","title":"dtmax  <code>property</code>","text":"<pre><code>dtmax: float\n</code></pre> <p>Floor (days) for the RMS evaluation window. Default: 30.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.dt_min","title":"dt_min  <code>property</code>","text":"<pre><code>dt_min: float\n</code></pre> <p>Minimum allowed span (days) between the first and last observations in a triplet. Default: 0.03.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.dt_max_triplet","title":"dt_max_triplet  <code>property</code>","text":"<pre><code>dt_max_triplet: float\n</code></pre> <p>Maximum allowed span (days) within any candidate triplet. Default: 150.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.optimal_interval_time","title":"optimal_interval_time  <code>property</code>","text":"<pre><code>optimal_interval_time: float\n</code></pre> <p>Target intra-triplet spacing (days) to favor well-separated observations. Default: 20.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.max_obs_for_triplets","title":"max_obs_for_triplets  <code>property</code>","text":"<pre><code>max_obs_for_triplets: int\n</code></pre> <p>Cap on observations used to build triplets (with uniform downsampling if exceeded). Default: 100.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.max_triplets","title":"max_triplets  <code>property</code>","text":"<pre><code>max_triplets: int\n</code></pre> <p>Maximum number of triplets evaluated per trajectory (post-filter). Default: 10.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.gap_max","title":"gap_max  <code>property</code>","text":"<pre><code>gap_max: float\n</code></pre> <p>Maximum allowed intra-batch time gap (days) for RMS calibration. Default: 8/24 (\u2248 0.3333).</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.max_ecc","title":"max_ecc  <code>property</code>","text":"<pre><code>max_ecc: float\n</code></pre> <p>Maximum accepted eccentricity. Default: 5.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.max_perihelion_au","title":"max_perihelion_au  <code>property</code>","text":"<pre><code>max_perihelion_au: float\n</code></pre> <p>Maximum accepted perihelion distance (AU). Default: 1.0e3.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.min_rho2_au","title":"min_rho2_au  <code>property</code>","text":"<pre><code>min_rho2_au: float\n</code></pre> <p>Minimum admissible topocentric distance at the central epoch (AU). Default: 0.01.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.r2_min_au","title":"r2_min_au  <code>property</code>","text":"<pre><code>r2_min_au: float\n</code></pre> <p>Lower plausibility bound on central heliocentric distance (AU). Default: 0.05.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.r2_max_au","title":"r2_max_au  <code>property</code>","text":"<pre><code>r2_max_au: float\n</code></pre> <p>Upper plausibility bound on central heliocentric distance (AU). Default: 200.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.aberth_max_iter","title":"aberth_max_iter  <code>property</code>","text":"<pre><code>aberth_max_iter: int\n</code></pre> <p>Maximum iterations for the Aberth\u2013Ehrlich polynomial solver. Default: 50.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.aberth_eps","title":"aberth_eps  <code>property</code>","text":"<pre><code>aberth_eps: float\n</code></pre> <p>Convergence tolerance for the Aberth solver. Default: 1.0e-6.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.kepler_eps","title":"kepler_eps  <code>property</code>","text":"<pre><code>kepler_eps: float\n</code></pre> <p>Tolerance used by the universal Kepler solver in velocity correction. Default: 1e3 * f64::EPSILON.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.max_tested_solutions","title":"max_tested_solutions  <code>property</code>","text":"<pre><code>max_tested_solutions: int\n</code></pre> <p>Cap on admissible Gauss solutions kept after root finding. Default: 3.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.newton_eps","title":"newton_eps  <code>property</code>","text":"<pre><code>newton_eps: float\n</code></pre> <p>Absolute tolerance for Newton\u2013Raphson inner solves. Default: 1.0e-10.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.newton_max_it","title":"newton_max_it  <code>property</code>","text":"<pre><code>newton_max_it: int\n</code></pre> <p>Maximum iterations for Newton\u2013Raphson inner solves. Default: 50.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.root_imag_eps","title":"root_imag_eps  <code>property</code>","text":"<pre><code>root_imag_eps: float\n</code></pre> <p>Max imaginary part magnitude to treat a complex root as real. Default: 1.0e-6.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.batch_size","title":"batch_size  <code>property</code>","text":"<pre><code>batch_size: int\n</code></pre> <p>Batch size for parallel trajectory processing. Only effective if the crate is compiled with the <code>parallel</code>/<code>rayon</code> feature. Default: 4.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.do_parallel","title":"do_parallel  <code>property</code>","text":"<pre><code>do_parallel: bool\n</code></pre> <p>Whether this configuration requests parallel execution in higher-level APIs.</p> Notes <p>This is carried alongside <code>IODParams</code> in the Python binding and consumed by callers (the core Rust struct is independent of this advisory flag).</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParams.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder() -&gt; IODParamsBuilder\n</code></pre> <p>Create a new <code>IODParamsBuilder</code> initialized with the Default values listed above.</p> RETURNS DESCRIPTION <code>IODParamsBuilder</code> <p>A fresh builder to customize and produce an <code>IODParams</code>.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder","title":"py_outfit.iod_params.IODParamsBuilder","text":"<pre><code>IODParamsBuilder()\n</code></pre> <p>Fluent builder for <code>IODParams</code>.</p> Defaults <p>The builder starts with the exact defaults documented in <code>IODParams</code> (see there).</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.n_noise_realizations","title":"n_noise_realizations","text":"<pre><code>n_noise_realizations(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Set the number of Monte Carlo perturbations per original triplet. Default: 20.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.noise_scale","title":"noise_scale","text":"<pre><code>noise_scale(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the scale applied to nominal astrometric uncertainties. Default: 1.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.extf","title":"extf","text":"<pre><code>extf(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the extrapolation factor for the RMS window (negative \u21d2 broad fallback). Window formula: <code>dt_window = (triplet span) \u00d7 v</code>, then clamp <code>\u2265 dtmax</code>. Default: -1.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.dtmax","title":"dtmax","text":"<pre><code>dtmax(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the minimum RMS window size (days). Default: 30.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.dt_min","title":"dt_min","text":"<pre><code>dt_min(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the minimum allowed span (days) between first and last obs in a triplet. Default: 0.03.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.dt_max_triplet","title":"dt_max_triplet","text":"<pre><code>dt_max_triplet(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum allowed span (days) within a triplet. Default: 150.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.optimal_interval_time","title":"optimal_interval_time","text":"<pre><code>optimal_interval_time(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the target intra-triplet spacing (days). Default: 20.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.max_obs_for_triplets","title":"max_obs_for_triplets","text":"<pre><code>max_obs_for_triplets(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Cap observations used to build triplets (uniform downsampling if exceeded). Default: 100.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.max_triplets","title":"max_triplets","text":"<pre><code>max_triplets(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Cap the number of triplets evaluated per trajectory. Default: 10.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.gap_max","title":"gap_max","text":"<pre><code>gap_max(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum intra-batch time gap (days) for RMS calibration. Default: 8/24.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.max_ecc","title":"max_ecc","text":"<pre><code>max_ecc(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum eccentricity accepted. Default: 5.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.max_perihelion_au","title":"max_perihelion_au","text":"<pre><code>max_perihelion_au(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum perihelion distance (AU). Default: 1.0e3.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.min_rho2_au","title":"min_rho2_au","text":"<pre><code>min_rho2_au(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the minimum topocentric distance at the central epoch (AU). Default: 0.01.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.r2_min_au","title":"r2_min_au","text":"<pre><code>r2_min_au(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the lower plausibility bound on heliocentric distance (AU). Default: 0.05.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.r2_max_au","title":"r2_max_au","text":"<pre><code>r2_max_au(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the upper plausibility bound on heliocentric distance (AU). Default: 200.0.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.aberth_max_iter","title":"aberth_max_iter","text":"<pre><code>aberth_max_iter(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum iterations for the Aberth\u2013Ehrlich solver. Default: 50.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.aberth_eps","title":"aberth_eps","text":"<pre><code>aberth_eps(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the Aberth convergence tolerance. Default: 1.0e-6.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.kepler_eps","title":"kepler_eps","text":"<pre><code>kepler_eps(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the universal Kepler solver tolerance. Default: 1e3 * f64::EPSILON.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.max_tested_solutions","title":"max_tested_solutions","text":"<pre><code>max_tested_solutions(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Cap the number of admissible solutions retained. Default: 3.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.newton_eps","title":"newton_eps","text":"<pre><code>newton_eps(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the Newton\u2013Raphson absolute tolerance. Default: 1.0e-10.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.newton_max_it","title":"newton_max_it","text":"<pre><code>newton_max_it(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Set the maximum Newton\u2013Raphson iterations. Default: 50.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.root_imag_eps","title":"root_imag_eps","text":"<pre><code>root_imag_eps(v: float) -&gt; IODParamsBuilder\n</code></pre> <p>Set the imaginary-part threshold to accept nearly-real roots. Default: 1.0e-6.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.batch_size","title":"batch_size","text":"<pre><code>batch_size(v: int) -&gt; IODParamsBuilder\n</code></pre> <p>Set the batch size for parallel scheduling. Effective only when the crate is compiled with the <code>parallel</code>/<code>rayon</code> feature. Default: 4.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.do_parallel","title":"do_parallel","text":"<pre><code>do_parallel() -&gt; IODParamsBuilder\n</code></pre> <p>Request parallel execution (Rayon-backed) in higher-level APIs that accept it. (Advisory flag carried by the Python binding; core Rust struct is independent.)</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.do_sequential","title":"do_sequential","text":"<pre><code>do_sequential() -&gt; IODParamsBuilder\n</code></pre> <p>Request sequential execution in higher-level APIs that accept it.</p>"},{"location":"api/iod_params/#py_outfit.iod_params.IODParamsBuilder.build","title":"build","text":"<pre><code>build() -&gt; IODParams\n</code></pre> <p>Finalize and materialize an immutable <code>IODParams</code> with the chosen settings.</p> RETURNS DESCRIPTION <code>IODParams</code> <p>A read-only <code>IODParams</code> instance with the configured parameters.</p>"},{"location":"api/observations/","title":"Observations","text":""},{"location":"api/observations/#py_outfit.observations.Observations","title":"py_outfit.observations.Observations","text":"<p>Read-only Python view over a single trajectory (list of astrometric observations).</p> Highlights <ul> <li>Vector exports: <code>to_numpy()</code> and <code>to_list()</code></li> <li>Row access / iteration: <code>__getitem__</code>, <code>__iter__</code></li> <li>Pretty display helpers:<ul> <li><code>show(...)</code> \u2013 compact, fixed-width table</li> <li><code>table_wide(...)</code> \u2013 diagnostic table with JD, radians, distances (AU)</li> <li><code>table_iso(...)</code> \u2013 timestamp-centric (ISO TT / ISO UTC)</li> <li><code>*_with_env(env, ...)</code> \u2013 same as above, but resolves observer names using <code>PyOutfit</code></li> </ul> </li> </ul>"},{"location":"api/observations/#py_outfit.observations.Observations.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; tuple[\n    NDArray[float64],\n    NDArray[float64],\n    NDArray[float64],\n    NDArray[float64],\n    NDArray[float64],\n]\n</code></pre> <p>Export arrays to NumPy (rad / days).</p> RETURNS DESCRIPTION <code>tuple[ndarray, ndarray, ndarray, ndarray, ndarray]</code> <p>Five 1D arrays of dtype float64: <code>(mjd_tt, ra_rad, dec_rad, sigma_ra, sigma_dec)</code>.</p>"},{"location":"api/observations/#py_outfit.observations.Observations.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[tuple[float, float, float, float, float]]\n</code></pre> <p>Return a Python list of observation tuples.</p> RETURNS DESCRIPTION <code>list[tuple[float, float, float, float, float]]</code> <p>Each tuple is <code>(mjd_tt, ra_rad, dec_rad, sigma_ra, sigma_dec)</code>.</p>"},{"location":"api/observations/#py_outfit.observations.Observations.show","title":"show","text":"<pre><code>show(*, sorted: bool = False, sec_prec: int = 3) -&gt; str\n</code></pre> <p>Render a compact, fixed-width table.</p> PARAMETER DESCRIPTION <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for sexagesimal seconds (default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted table.</p>"},{"location":"api/observations/#py_outfit.observations.Observations.show_with_env","title":"show_with_env","text":"<pre><code>show_with_env(env: PyOutfit, *, sorted: bool = False, sec_prec: int = 3) -&gt; str\n</code></pre> <p>Compact table, resolving observer names via <code>env</code>.</p> PARAMETER DESCRIPTION <code>env</code> <p>Global environment used to resolve site names.</p> <p> TYPE: <code>PyOutfit</code> </p> <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for sexagesimal seconds (default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted table (with site names when available).</p>"},{"location":"api/observations/#py_outfit.observations.Observations.table_wide","title":"table_wide","text":"<pre><code>table_wide(*, sorted: bool = False, sec_prec: int = 3, dist_prec: int = 6) -&gt; str\n</code></pre> <p>Diagnostic table (Unicode) with JD, radians, and AU distances.</p> Columns <p><code># | Site | MJD (TT) | JD (TT) | RA\u00b1\u03c3[arcsec] | RA [rad] | DEC\u00b1\u03c3[arcsec] | DEC [rad] | |r_geo| AU | |r_hel| AU</code></p> PARAMETER DESCRIPTION <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for sexagesimal seconds (default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>dist_prec</code> <p>Fixed-point digits for AU distances (default: 6).</p> <p> TYPE: <code>int</code> DEFAULT: <code>6</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Unicode table (box drawing).</p>"},{"location":"api/observations/#py_outfit.observations.Observations.table_wide_with_env","title":"table_wide_with_env","text":"<pre><code>table_wide_with_env(\n    env: PyOutfit, *, sorted: bool = False, sec_prec: int = 3, dist_prec: int = 6\n) -&gt; str\n</code></pre> <p>Diagnostic table (Unicode) using <code>env</code> to resolve observer names.</p> <p>See <code>table_wide</code> for columns and knobs.</p> PARAMETER DESCRIPTION <code>env</code> <p>Global environment used to resolve site names.</p> <p> TYPE: <code>PyOutfit</code> </p> <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for sexagesimal seconds (default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>dist_prec</code> <p>Fixed-point digits for AU distances (default: 6).</p> <p> TYPE: <code>int</code> DEFAULT: <code>6</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Unicode table (box drawing).</p>"},{"location":"api/observations/#py_outfit.observations.Observations.table_iso","title":"table_iso","text":"<pre><code>table_iso(*, sorted: bool = False, sec_prec: int = 3) -&gt; str\n</code></pre> <p>ISO-centric table (Unicode) with TT &amp; UTC timestamps.</p> Columns <p><code># | Site | ISO (TT) | ISO (UTC) | RA\u00b1\u03c3[arcsec] | DEC\u00b1\u03c3[arcsec]</code></p> PARAMETER DESCRIPTION <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for seconds (applied to ISO &amp; sexagesimal, default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Unicode table (box drawing).</p>"},{"location":"api/observations/#py_outfit.observations.Observations.table_iso_with_env","title":"table_iso_with_env","text":"<pre><code>table_iso_with_env(env: PyOutfit, *, sorted: bool = False, sec_prec: int = 3) -&gt; str\n</code></pre> <p>ISO-centric table (Unicode) using <code>env</code> to resolve observer names.</p> <p>See <code>table_iso</code> for columns and knobs.</p> PARAMETER DESCRIPTION <code>env</code> <p>Global environment used to resolve site names.</p> <p> TYPE: <code>PyOutfit</code> </p> <code>sorted</code> <p>Sort rows by MJD(TT) ascending (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>sec_prec</code> <p>Fractional digits for seconds (applied to ISO &amp; sexagesimal, default: 3).</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Unicode table (box drawing).</p>"},{"location":"api/observations/#py_outfit.observations.Observations.estimate_best_orbit","title":"estimate_best_orbit","text":"<pre><code>estimate_best_orbit(\n    env: PyOutfit, params: IODParams, seed: Optional[int] = ...\n) -&gt; Tuple[GaussResult, float]\n</code></pre> <p>Estimate the best orbit for this observation set using Gauss IOD.</p> PARAMETER DESCRIPTION <code>env</code> <p>Global environment providing ephemerides and the error model.</p> <p> TYPE: <code>PyOutfit</code> </p> <code>params</code> <p>IOD configuration (triplet constraints, noise realizations, filters).</p> <p> TYPE: <code>IODParams</code> </p> <code>seed</code> <p>Optional RNG seed for deterministic runs.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Notes <p>Due to a known bug in the Rust backend (Outfit) within <code>apply_batch_rms_correction</code>, the per-observation uncertainties <code>(sigma_ra, sigma_dec)</code> are modified in place and the changes persist on the same <code>Observations</code> instance. Calling <code>estimate_best_orbit</code> multiple times on the same object can therefore accumulate these changes and yield different RMS values across calls. This behavior is unintended and will be fixed upstream. As a temporary workaround, construct a fresh <code>Observations</code> object for each call or use a copy that restores the original uncertainties. Providing a <code>seed</code> only makes noise sampling deterministic and does not prevent this mutation.</p> RETURNS DESCRIPTION <code>(GaussResult, float)</code> <p>The orbit result and the RMS value (radians).</p>"},{"location":"api/observer/","title":"Observer","text":""},{"location":"api/observer/#py_outfit.observer.Observer","title":"py_outfit.observer.Observer","text":"<pre><code>Observer(\n    longitude: float,\n    latitude: float,\n    elevation: float,\n    name: Optional[str] = ...,\n    ra_accuracy: Optional[float] = ...,\n    dec_accuracy: Optional[float] = ...,\n)\n</code></pre> <p>Observatory/site descriptor.</p> <p>Instances are typically obtained from <code>PyOutfit.get_observer_from_mpc_code(...)</code>  or built directly via the constructor below and then registered with <code>PyOutfit.add_observer(...)</code></p> Notes <p>The underlying Rust struct carries geodetic/ITRF position, codes, and precomputed parallax factors for astrometric use. In Python, this is an opaque handle; fields are not directly writable.</p> See also <ul> <li><code>PyOutfit.add_observer</code> \u2013 Register this observer into an environment.</li> </ul> RETURNS DESCRIPTION <code>Observer</code> <p>A new <code>Observer</code> instance.</p> Notes <p>Internally, the Rust implementation converts geodetic coordinates to \u201cparallax\u201d form for precise topocentric astrometry. Accuracy fields can be used by error models during orbit determination.</p>"},{"location":"api/pandas_pyoutfit/","title":"Integration with Pandas","text":""},{"location":"api/pandas_pyoutfit/#py_outfit.pandas_pyoutfit","title":"py_outfit.pandas_pyoutfit","text":"<p>Pandas accessor for batch Initial Orbit Determination (IOD) with Outfit.</p> <p>This module adds a <code>DataFrame.outfit</code> accessor exposing a vectorized entry-point to run Gauss IOD on a flat, columnar table of astrometric measurements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     \"tid\":  [0, 0, 0, 1, 1, 1],\n...     \"mjd\":  [60000.0, 60000.01, 60000.02, 60000.0, 60000.01, 60000.02],\n...     \"ra\":   [10.1, 10.2, 10.3, 33.4, 33.5, 33.6],   # degrees by default\n...     \"dec\":  [-5.0, -4.9, -4.8,  2.0,  2.1,  2.2],  # degrees by default\n... })\n&gt;&gt;&gt; env = PyOutfit(ephem=\"horizon:DE440\", error_model=\"FCCT14\")\n&gt;&gt;&gt; params = IODParams() # default settings\n&gt;&gt;&gt; obs = PyOutfit.get_observer_from_mpc_code(\"I41\") # ZTF\n&gt;&gt;&gt; orb_pdf = pandas_traj.outfit.estimate_orbits(\n...     env, params, obs, ra_error=0.5, dec_error=0.5\n... )\n&gt;&gt;&gt; orb_pdf.columns[:5]\nIndex(['object_id', 'variant', 'element_set', 'rms', ...], dtype='object')\n</code></pre> Design <ul> <li>Schema: maps your column names to the expected fields (<code>tid/mjd/ra/dec</code>).</li> <li>Vector ingestion: we assemble a <code>TrajectorySet</code> directly from NumPy arrays.</li> <li>Units: <code>units=\"degrees\"</code> (default) interprets RA/DEC in degrees and   uncertainties in arcseconds; <code>\"radians\"</code> expects everything in radians.</li> </ul>"},{"location":"api/pandas_pyoutfit/#py_outfit.pandas_pyoutfit.Schema","title":"Schema  <code>dataclass</code>","text":"<pre><code>Schema(tid: str = 'tid', mjd: str = 'mjd', ra: str = 'ra', dec: str = 'dec')\n</code></pre> <p>Column schema used to map a DataFrame to py_outfit's vector ingestion.</p> ATTRIBUTE DESCRIPTION <code>tid</code> <p>Column containing object/trajectory IDs (int or str). Repeated per-row.</p> <p> TYPE: <code>str</code> </p> <code>mjd</code> <p>Modified Julian Date (TT, days).</p> <p> TYPE: <code>str</code> </p> <code>ra</code> <p>Right Ascension values (degrees if <code>units='degrees'</code>, else radians).</p> <p> TYPE: <code>str</code> </p> <code>dec</code> <p>Declination values (degrees if <code>units='degrees'</code>, else radians).</p> <p> TYPE: <code>str</code> </p> Notes <ul> <li>Only these four columns are required for the accessor.</li> <li>If your DataFrame uses different names, override the defaults:   <code>schema=Schema(tid=\"object\", mjd=\"epoch\", ra=\"alpha\", dec=\"delta\")</code>.</li> </ul>"},{"location":"api/pandas_pyoutfit/#py_outfit.pandas_pyoutfit.OutfitAccessor","title":"OutfitAccessor","text":"<pre><code>OutfitAccessor(pandas_obj: DataFrame)\n</code></pre> <p>Pandas accessor for running Gauss IOD from a DataFrame.</p> <p>Use via the attribute accessor <code>DataFrame.outfit</code>. It exposes :meth:<code>estimate_orbits</code> to run a vectorized Initial Orbit Determination over a flat table of astrometric measurements.</p> <p>Examples:</p> <p>Basic usage with degrees and arcseconds</p> <pre><code>&gt;&gt;&gt; out = df.outfit.estimate_orbits(env, params, observer, ra_error=0.5, dec_error=0.5)\n</code></pre> <p>Radians workflow</p> <pre><code>&gt;&gt;&gt; out = df.outfit.estimate_orbits(\n...     env, params, observer,\n...     ra_error=1e-6, dec_error=1e-6,\n...     units=\"radians\",\n... )\n</code></pre>"},{"location":"api/pandas_pyoutfit/#py_outfit.pandas_pyoutfit.OutfitAccessor.estimate_orbits","title":"estimate_orbits","text":"<pre><code>estimate_orbits(\n    env: PyOutfit,\n    params: IODParams,\n    observer: Observer,\n    ra_error: float,\n    dec_error: float,\n    *,\n    schema: Schema = Schema(),\n    units: Literal[\"degrees\", \"radians\"] = \"degrees\",\n    rng_seed: Optional[int] = None\n) -&gt; DataFrame\n</code></pre> <p>Run Gauss IOD on a flat astrometry table and return a one-row-per-object summary.</p> <p>The input DataFrame must at least provide a trajectory/object identifier, Modified Julian Date in TT, and right ascension/declination angles. The names of these columns are defined by <code>schema</code> (defaults are <code>tid</code>, <code>mjd</code>, <code>ra</code>, <code>dec</code>).</p> PARAMETER DESCRIPTION <code>env</code> <p>Configured computation engine, including ephemerides, the error model and the available observers.</p> <p> TYPE: <code>PyOutfit</code> </p> <code>params</code> <p>IOD configuration controlling triplet search, Monte Carlo perturbations, filters, and tolerances.</p> <p> TYPE: <code>IODParams</code> </p> <code>observer</code> <p>Default observer applied to all rows. This covers the common single-station use case.</p> <p> TYPE: <code>Observer</code> </p> <code>ra_error</code> <p>Uncertainty on right ascension. When <code>units=\"degrees\"</code>, the value is interpreted in arcseconds; when <code>units=\"radians\"</code>, the value is in radians.</p> <p> TYPE: <code>float</code> </p> <code>dec_error</code> <p>Uncertainty on declination. Follows the same unit convention as <code>ra_error</code>.</p> <p> TYPE: <code>float</code> </p> <code>schema</code> <p>Column mapping for the current DataFrame. Use this to adapt to non-standard column names. The default expects <code>tid</code>, <code>mjd</code>, <code>ra</code>, and <code>dec</code>.</p> <p> TYPE: <code>Schema</code> DEFAULT: <code>Schema()</code> </p> <code>units</code> <p>Angle units for <code>ra</code>/<code>dec</code> and the corresponding uncertainties. Degrees imply RA/DEC are in degrees and uncertainties are in arcseconds. Radians imply both values and uncertainties are already expressed in radians.</p> <p> TYPE: <code>('degrees', 'radians')</code> DEFAULT: <code>\"degrees\"</code> </p> <code>rng_seed</code> <p>Optional seed to make randomized internals deterministic.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>A summary DataFrame with one row per object containing the RMS value, the detected orbital element set, the orbit variant, and the native orbital elements returned by the engine. The <code>object_id</code> column mirrors the original identifier from <code>schema.tid</code>. When some trajectories fail, additional rows are included with <code>object_id</code> and an <code>error</code> message; successful rows include <code>status=\"ok\"</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raised when required columns are missing in the DataFrame, or when <code>units</code> is not one of {\"degrees\", \"radians\"}.</p> Notes <p>Ingestion is vectorized and avoids Python-level grouping. For <code>units=\"degrees\"</code>, <code>ra_error</code> and <code>dec_error</code> are converted from arcseconds to radians using <code>RADSEC</code>. If needed, multi-observer or per-row observatory support can be added by extending the <code>TrajectorySet.from_numpy_*</code> builder to accept vectorized observers.</p> See Also <ul> <li> <p><code>TrajectorySet.estimate_all_orbits</code>:     Batch Gauss IOD over trajectories.</p> </li> <li> <p><code>GaussResult.to_dict</code>:     Native orbital element names used in the output.</p> </li> <li> <p><code>Schema</code>:     Column mapping used to interpret the input DataFrame.</p> </li> </ul>"},{"location":"api/py_outfit/","title":"PyOutfit","text":"<p>Physical and astronomical constants exposed by Outfit.</p> <p>These values are provided in SI units or astronomical conventions</p>"},{"location":"api/py_outfit/#py_outfit.PyOutfit","title":"py_outfit.PyOutfit","text":"<pre><code>PyOutfit(ephem: str, error_model: str)\n</code></pre> <p>pyOutfit: Python bindings for the Outfit orbit-determination engine.</p> <p>Provides a thin, Pythonic surface around the Rust core <code>Outfit</code>, exposing: - High-precision ephemerides configuration (e.g., DE440). - Observatories management (MPC code lookup, listing). - Gauss-based initial orbit determination (via other types in this module).</p> See also <ul> <li><code>Outfit</code> \u2013 Core Rust engine (linked from the Rust docs).</li> <li><code>IODParams</code> \u2013 Tuning parameters for Gauss IOD.</li> <li><code>TrajectorySet</code> \u2013 Batched ingestion and IOD helpers.</li> <li><code>Observer</code> \u2013 Observing site handle.</li> </ul> PARAMETER DESCRIPTION <code>ephem</code> <p>Ephemerides selector in the form \"{source}:{version}\". The source must be \"horizon\" (legacy JPL DE binaries) or \"naif\" (NAIF SPK/DAF kernels). The version must be a supported DE series label recognized by Outfit. Common values include \"DE430\", \"DE431\", \"DE440\", \"DE441\", and \"DE442\". Examples include \"horizon:DE440\" and \"naif:DE441\". The ephemeris file is resolved into the user cache and opened lazily; when downloads are enabled at build time, a missing file may be fetched automatically, otherwise an error is raised.</p> <p> TYPE: <code>str</code> </p> <code>error_model</code> <p>Astrometric error model. Accepted values are \"FCCT14\", \"VFCC17\", and \"CBM10\". Unknown strings default to \"FCCT14\". The model provides per-site RA/DEC bias and RMS used during orbit determination.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>PyOutfit</code> <p>An initialized <code>PyOutfit</code> environment.</p>"},{"location":"api/py_outfit/#py_outfit.PyOutfit.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer: Observer) -&gt; None\n</code></pre> <p>Register an <code>Observer</code> in the current environment.</p> PARAMETER DESCRIPTION <code>observer</code> <p>The observatory/site descriptor to register.</p> <p> TYPE: <code>Observer</code> </p>"},{"location":"api/py_outfit/#py_outfit.PyOutfit.show_observatories","title":"show_observatories","text":"<pre><code>show_observatories() -&gt; str\n</code></pre> <p>Render a human-readable list of currently known observatories.</p> RETURNS DESCRIPTION <code>str</code> <p>A formatted <code>str</code> (table/list) of observatories.</p>"},{"location":"api/py_outfit/#py_outfit.PyOutfit.get_observer_from_mpc_code","title":"get_observer_from_mpc_code","text":"<pre><code>get_observer_from_mpc_code(code: str) -&gt; Observer\n</code></pre> <p>Lookup an <code>Observer</code> from its MPC code.</p> PARAMETER DESCRIPTION <code>code</code> <p>MPC observatory code, e.g. \"807\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Observer</code> <p>an <code>Observer</code> handle usable with <code>add_observer</code>.</p>"},{"location":"api/py_outfit/#py_outfit","title":"py_outfit","text":""},{"location":"api/py_outfit/#py_outfit-attributes","title":"Attributes","text":""},{"location":"api/py_outfit/#py_outfit.DPI","title":"DPI  <code>module-attribute</code>","text":"<pre><code>DPI: float = 6.283185307179586\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.SECONDS_PER_DAY","title":"SECONDS_PER_DAY  <code>module-attribute</code>","text":"<pre><code>SECONDS_PER_DAY: float = 86400.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870.7\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.EPS","title":"EPS  <code>module-attribute</code>","text":"<pre><code>EPS: float = 1e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.T2000","title":"T2000  <code>module-attribute</code>","text":"<pre><code>T2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.JDTOMJD","title":"JDTOMJD  <code>module-attribute</code>","text":"<pre><code>JDTOMJD: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.RADEG","title":"RADEG  <code>module-attribute</code>","text":"<pre><code>RADEG: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.RADSEC","title":"RADSEC  <code>module-attribute</code>","text":"<pre><code>RADSEC: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.RAD2ARC","title":"RAD2ARC  <code>module-attribute</code>","text":"<pre><code>RAD2ARC: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.RADH","title":"RADH  <code>module-attribute</code>","text":"<pre><code>RADH: float = 0.2617993877991494\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.GAUSS_GRAV","title":"GAUSS_GRAV  <code>module-attribute</code>","text":"<pre><code>GAUSS_GRAV: float = 0.01720209895\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.GAUSS_GRAV_SQUARED","title":"GAUSS_GRAV_SQUARED  <code>module-attribute</code>","text":"<pre><code>GAUSS_GRAV_SQUARED: float = 0.00029591220828559115\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.VLIGHT","title":"VLIGHT  <code>module-attribute</code>","text":"<pre><code>VLIGHT: float = 299792.458\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit.VLIGHT_AU","title":"VLIGHT_AU  <code>module-attribute</code>","text":"<pre><code>VLIGHT_AU: float = 173.14463267424034\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"api/py_outfit/#py_outfit-classes","title":"Classes","text":""},{"location":"api/trajectories/","title":"Trajectories","text":""},{"location":"api/trajectories/#py_outfit.trajectories.Key","title":"py_outfit.trajectories.Key  <code>module-attribute</code>","text":"<pre><code>Key = Union[int, str]\n</code></pre> <p>Key used to identify a trajectory (either by its MPC code, a string ID or just an integer).</p>"},{"location":"api/trajectories/#py_outfit.trajectories.PathLike","title":"py_outfit.trajectories.PathLike  <code>module-attribute</code>","text":"<pre><code>PathLike = Union[str, Path]\n</code></pre> <p>Path-like type (either a <code>str</code> or a <code>Path</code> from <code>pathlib</code>).</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet","title":"py_outfit.trajectories.TrajectorySet","text":"<p>Container for time\u2011ordered astrometric observations grouped by object identifiers, designed as the primary entry point for batch workflows.</p> <p>A TrajectorySet represents a mapping from a user-supplied key to a time\u2011ordered view of observations for that object. It enables loading large collections of observations, inspecting basic statistics, and running Gauss-based Initial Orbit Determination across all trajectories in a single operation. Keys can be integers or strings and are preserved end\u2011to\u2011end, making it straightforward to relate results back to upstream catalogs or pipeline identifiers.</p> <p>The container behaves like a Python dictionary for common operations such as membership tests, iteration, indexing, and length queries. Each entry provides a read\u2011only Observations view that exposes per\u2011trajectory data without copying, keeping memory usage predictable. This structure is intended to integrate cleanly with scientific Python workflows while delegating all heavy computation to the Rust engine underneath.</p> <p>Ingestion supports two main paths. A zero\u2011copy path accepts right ascension and declination in radians, epochs in MJD (TT), and a single Observer for the entire batch. A compatible degrees and arcseconds path performs a single conversion to radians before storing data. Trajectories can also be constructed from standard astronomy formats such as MPC 80\u2011column and ADES (JSON or XML), and an existing set can be extended by appending additional files when needed.</p> <p>The container is optimized for batch IOD. The dedicated batch method executes the Gauss solver over all stored trajectories using parameters supplied by IODParams and returns per\u2011trajectory outcomes together with error messages for failures. Execution may be sequential or parallel depending on configuration, with optional deterministic seeding for reproducibility. When run sequentially, cooperative cancellation allows returning partial results if interrupted by the user.</p> <p>The type does not perform de\u2011duplication or cross\u2011trajectory merging and assumes inputs are pre\u2011grouped as intended. Units follow the package conventions: angles are treated in radians internally, epochs use MJD (TT), and when ingesting degrees the provided uncertainties are interpreted in arcseconds. A single observing site applies per ingestion call. The overall goal is to make data flow explicit, predictable, and efficient for production pipelines.</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.keys","title":"keys","text":"<pre><code>keys() -&gt; list[Key]\n</code></pre> <p>Return the list of keys (like <code>dict.keys()</code>).</p> RETURNS DESCRIPTION <code>list[Key]</code> <p>A list of all object identifiers currently stored.</p> See also <ul> <li><code>values</code> \u2013 All trajectories.</li> <li><code>items</code> \u2013 Key/value pairs.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.values","title":"values","text":"<pre><code>values() -&gt; list[Observations]\n</code></pre> <p>Return the list of trajectories (like <code>dict.values()</code>).</p> RETURNS DESCRIPTION <code>list[Observations]</code> <p>A list of all <code>Observations</code> currently stored.</p> See also <ul> <li><code>keys</code> \u2013 All keys.</li> <li><code>items</code> \u2013 Key/value pairs.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.items","title":"items","text":"<pre><code>items() -&gt; list[tuple[Key, Observations]]\n</code></pre> <p>Return the list of <code>(key, Observations)</code> pairs (like <code>dict.items()</code>).</p> RETURNS DESCRIPTION <code>list[tuple[Key, Observations]]</code> <p>A list of all <code>(object_id, Observations)</code> pairs currently stored.</p> See also <ul> <li><code>keys</code> \u2013 All keys.</li> <li><code>values</code> \u2013 All trajectories.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.total_observations","title":"total_observations","text":"<pre><code>total_observations() -&gt; int\n</code></pre> <p>Total number of observations across all trajectories.</p> RETURNS DESCRIPTION <code>int</code> <p>sum over all per-trajectory counts.</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.number_of_trajectories","title":"number_of_trajectories","text":"<pre><code>number_of_trajectories() -&gt; int\n</code></pre> <p>Number of trajectories currently stored.</p> RETURNS DESCRIPTION <code>int</code> <p>number of distinct trajectory IDs.</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.get_traj_stat","title":"get_traj_stat","text":"<pre><code>get_traj_stat() -&gt; str\n</code></pre> <p>Pretty-printed statistics about observations per trajectory.</p> RETURNS DESCRIPTION <code>str</code> <p>A formatted <code>str</code> (histogram/stats), or <code>\"No trajectories available.\"</code> if empty.</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.from_numpy_radians","title":"from_numpy_radians  <code>staticmethod</code>","text":"<pre><code>from_numpy_radians(\n    pyoutfit: PyOutfit,\n    trajectory_id: NDArray[uint32],\n    ra: NDArray[float64],\n    dec: NDArray[float64],\n    error_ra_rad: float,\n    error_dec_rad: float,\n    mjd_tt: NDArray[float64],\n    observer: Observer,\n) -&gt; \"TrajectorySet\"\n</code></pre> <p>Build a <code>TrajectorySet</code> from arrays already in radians (RA/DEC) and MJD (TT).</p> <p>This path uses a zero-copy ingestion under the hood.</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>trajectory_id</code> <p><code>np.uint32</code> array \u2014 one ID per observation.</p> <p> TYPE: <code>NDArray[uint32]</code> </p> <code>ra</code> <p><code>np.float64</code> array \u2014 Right Ascension in radians.</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>dec</code> <p><code>np.float64</code> array \u2014 Declination in radians.</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>error_ra_rad</code> <p>1-\u03c3 RA uncertainty (radians) applied to the whole batch.</p> <p> TYPE: <code>float</code> </p> <code>error_dec_rad</code> <p>1-\u03c3 DEC uncertainty (radians) applied to the whole batch.</p> <p> TYPE: <code>float</code> </p> <code>mjd_tt</code> <p><code>np.float64</code> array \u2014 epochs in MJD (TT) (days).</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>observer</code> <p>Single observing site for the whole batch.</p> <p> TYPE: <code>Observer</code> </p> RETURNS DESCRIPTION <code>TrajectorySet</code> <p>A new <code>TrajectorySet</code> populated from the provided inputs.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if input arrays have mismatched lengths.</p>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.from_numpy_degrees","title":"from_numpy_degrees  <code>staticmethod</code>","text":"<pre><code>from_numpy_degrees(\n    pyoutfit: PyOutfit,\n    trajectory_id: NDArray[uint32],\n    ra_deg: NDArray[float64],\n    dec_deg: NDArray[float64],\n    error_ra_arcsec: float,\n    error_dec_arcsec: float,\n    mjd_tt: NDArray[float64],\n    observer: Observer,\n) -&gt; \"TrajectorySet\"\n</code></pre> <p>Build a <code>TrajectorySet</code> from degrees (RA/DEC), arcseconds (uncertainties), and MJD (TT) for epochs.</p> <p>Internally converts once to radians, then ingests.</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>trajectory_id</code> <p><code>np.uint32</code> array \u2014 one ID per observation.</p> <p> TYPE: <code>NDArray[uint32]</code> </p> <code>ra_deg</code> <p><code>np.float64</code> array \u2014 Right Ascension in degrees.</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>dec_deg</code> <p><code>np.float64</code> array \u2014 Declination in degrees.</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>error_ra_arcsec</code> <p>1-\u03c3 RA uncertainty (arcseconds) applied to the batch.</p> <p> TYPE: <code>float</code> </p> <code>error_dec_arcsec</code> <p>1-\u03c3 DEC uncertainty (arcseconds) applied to the batch.</p> <p> TYPE: <code>float</code> </p> <code>mjd_tt</code> <p><code>np.float64</code> array \u2014 epochs in MJD (TT) (days).</p> <p> TYPE: <code>NDArray[float64]</code> </p> <code>observer</code> <p>Single observing site for the whole batch.</p> <p> TYPE: <code>Observer</code> </p> RETURNS DESCRIPTION <code>TrajectorySet</code> <p>A new <code>TrajectorySet</code> populated from the provided inputs.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if input arrays have mismatched lengths.</p> See also <ul> <li><code>from_numpy_radians</code> \u2014 Zero-copy variant for radian inputs.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.new_from_mpc_80col","title":"new_from_mpc_80col  <code>staticmethod</code>","text":"<pre><code>new_from_mpc_80col(pyoutfit: PyOutfit, path: PathLike) -&gt; 'TrajectorySet'\n</code></pre> <p>Build a <code>TrajectorySet</code> from a MPC 80-column file.</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>path</code> <p>File path (<code>str</code> or Path from pathlib) to a MPC 80-column text file.</p> <p> TYPE: <code>PathLike</code> </p> RETURNS DESCRIPTION <code>TrajectorySet</code> <p>A new <code>TrajectorySet</code> populated from the file contents.</p> Notes <ul> <li>Mirrors the Rust API semantics and may panic on parse errors.</li> </ul> See also <ul> <li><code>add_from_mpc_80col</code> \u2014 Append a second 80-column file into an existing set.</li> <li><code>new_from_ades</code> \u2014 Create from ADES JSON/XML.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.add_from_mpc_80col","title":"add_from_mpc_80col","text":"<pre><code>add_from_mpc_80col(pyoutfit: PyOutfit, path: PathLike) -&gt; None\n</code></pre> <p>Append observations from a MPC 80-column file into this set.</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>path</code> <p>File path (<code>str</code> or Path from pathlib) to a MPC 80-column text file.</p> <p> TYPE: <code>PathLike</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The internal map is updated in place.</p> Notes <ul> <li>No de-duplication is performed; avoid ingesting the same file twice.</li> </ul> See also <ul> <li><code>new_from_mpc_80col</code> \u2014 Create a brand-new set from a single file.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.new_from_ades","title":"new_from_ades  <code>staticmethod</code>","text":"<pre><code>new_from_ades(\n    pyoutfit: PyOutfit,\n    path: PathLike,\n    error_ra_arcsec: Optional[float],\n    error_dec_arcsec: Optional[float],\n) -&gt; \"TrajectorySet\"\n</code></pre> <p>Build a <code>TrajectorySet</code> from an ADES file (JSON or XML).</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>path</code> <p>File path (<code>str</code> or Path from pathlib) to an ADES JSON/XML file.</p> <p> TYPE: <code>PathLike</code> </p> <code>error_ra_arcsec</code> <p>Optional global RA 1-\u03c3 (arcsec) if not specified per row.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>error_dec_arcsec</code> <p>Optional global DEC 1-\u03c3 (arcsec) if not specified per row.</p> <p> TYPE: <code>Optional[float]</code> </p> RETURNS DESCRIPTION <code>TrajectorySet</code> <p>A new <code>TrajectorySet</code> populated from the ADES file.</p> Notes <ul> <li>Error-handling policy follows the underlying parser (may log or panic).</li> </ul> See also <ul> <li><code>add_from_ades</code> \u2014 Append ADES observations into an existing set.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.add_from_ades","title":"add_from_ades","text":"<pre><code>add_from_ades(\n    pyoutfit: PyOutfit,\n    path: PathLike,\n    error_ra_arcsec: Optional[float],\n    error_dec_arcsec: Optional[float],\n) -&gt; None\n</code></pre> <p>Append observations from an ADES file (JSON/XML) into this set.</p> PARAMETER DESCRIPTION <code>pyoutfit</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>path</code> <p>File path (<code>str</code> or Path from pathlib) to an ADES JSON/XML file.</p> <p> TYPE: <code>PathLike</code> </p> <code>error_ra_arcsec</code> <p>Optional global RA 1-\u03c3 (arcsec) if not specified per row.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>error_dec_arcsec</code> <p>Optional global DEC 1-\u03c3 (arcsec) if not specified per row.</p> <p> TYPE: <code>Optional[float]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The internal map is updated in place.</p> Notes <ul> <li>No de-duplication is performed; avoid re-ingesting the same file.</li> </ul> See also <ul> <li><code>new_from_ades</code> \u2014 Create a brand-new set from a single ADES file.</li> </ul>"},{"location":"api/trajectories/#py_outfit.trajectories.TrajectorySet.estimate_all_orbits","title":"estimate_all_orbits","text":"<pre><code>estimate_all_orbits(\n    env: PyOutfit, params: IODParams, seed: Optional[int] = ...\n) -&gt; Tuple[Dict[Any, Tuple[GaussResult, float]], Dict[Any, str]]\n</code></pre> <p>Estimate the best orbit for all trajectories in this set.</p> <p>Runs Gauss-based IOD for each trajectory using the provided environment and parameters. Internally creates a RNG: - if <code>seed</code> is provided \u2192 deterministic <code>StdRng::seed_from_u64(seed)</code>; - else \u2192 <code>StdRng::from_os_rng()</code>.</p> Cancellation <p>The computation periodically checks for <code>KeyboardInterrupt</code> (Ctrl-C).  This work only if parallel is disabled (<code>params.do_parallel() == False</code>). If parallel is enabled, the computation cannot be interrupted and you will need to kill the process manually.</p> <p>If cancellation is triggered, partial results accumulated so far are returned:</p> <ul> <li>the first dict contains successful <code>(GaussResult, rms)</code> per object,</li> <li>the second dict contains error messages per object.</li> </ul> PARAMETER DESCRIPTION <code>env</code> <p>Global environment (ephemerides, observers, error model).</p> <p> TYPE: <code>PyOutfit</code> </p> <code>params</code> <p>IOD tuning parameters (<code>IODParams</code>). If <code>params.do_parallel()</code> is <code>True</code>, a parallel path is used internally; otherwise a sequential path with cooperative cancellation.</p> <p> TYPE: <code>IODParams</code> </p> <code>seed</code> <p>Optional RNG seed for reproducibility.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>...</code> </p> RETURNS DESCRIPTION <code>ok</code> <p>successful gauss results with RMS,</p> <p> TYPE: <code>Dict[object_id, (GaussResult, float)]</code> </p> <code>err</code> <p>error messages for failed trajectories.</p> <p> TYPE: <code>Dict[object_id, str]</code> </p> Notes <ul> <li><code>object_id</code> preserves the input trajectory identifiers (either <code>int</code>   or <code>str</code>, depending on how trajectories were ingested).</li> <li>The RMS value is engine-defined (e.g., post-fit residual RMS in radians).</li> </ul>"},{"location":"api/orbit_type/cometary/","title":"Cometary Elements","text":""},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements","title":"py_outfit.orbit_type.cometary.CometaryElements","text":"<pre><code>CometaryElements(\n    reference_epoch: float,\n    perihelion_distance: float,\n    eccentricity: float,\n    inclination: float,\n    ascending_node_longitude: float,\n    periapsis_argument: float,\n    true_anomaly: float,\n)\n</code></pre> <p>Cometary orbital elements (q, e \u2265 1, i, \u03a9, \u03c9, \u03bd).</p> Units <ul> <li><code>reference_epoch</code>: MJD (TDB)</li> <li><code>perihelion_distance</code> (q): AU</li> <li><code>eccentricity</code> (e): dimensionless; <code>e = 1</code> parabolic, <code>e &gt; 1</code> hyperbolic</li> <li><code>inclination</code> (i): radians</li> <li><code>ascending_node_longitude</code> (\u03a9): radians</li> <li><code>periapsis_argument</code> (\u03c9): radians</li> <li><code>true_anomaly</code> (\u03bd): radians at reference epoch</li> </ul> See also <ul> <li><code>to_keplerian</code> \u2014 Convert to Keplerian (hyperbolic only).</li> <li><code>to_equinoctial</code> \u2014 Convert to Equinoctial (hyperbolic only).</li> </ul> RETURNS DESCRIPTION <code>CometaryElements</code> <p>A new cometary element set.</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.reference_epoch","title":"reference_epoch  <code>property</code>","text":"<pre><code>reference_epoch: float\n</code></pre> <p>Reference epoch of the element set (MJD, TDB).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.perihelion_distance","title":"perihelion_distance  <code>property</code>","text":"<pre><code>perihelion_distance: float\n</code></pre> <p>Perihelion distance q (AU).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.eccentricity","title":"eccentricity  <code>property</code>","text":"<pre><code>eccentricity: float\n</code></pre> <p>Eccentricity e (dimensionless). For cometary: e \u2265 1.</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.inclination","title":"inclination  <code>property</code>","text":"<pre><code>inclination: float\n</code></pre> <p>Inclination i (radians).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.ascending_node_longitude","title":"ascending_node_longitude  <code>property</code>","text":"<pre><code>ascending_node_longitude: float\n</code></pre> <p>Longitude of the ascending node \u03a9 (radians).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.periapsis_argument","title":"periapsis_argument  <code>property</code>","text":"<pre><code>periapsis_argument: float\n</code></pre> <p>Argument of periapsis \u03c9 (radians).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.true_anomaly","title":"true_anomaly  <code>property</code>","text":"<pre><code>true_anomaly: float\n</code></pre> <p>True anomaly \u03bd at the reference epoch (radians).</p>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.to_keplerian","title":"to_keplerian","text":"<pre><code>to_keplerian() -&gt; KeplerianElements\n</code></pre> <p>Convert cometary \u2192 Keplerian elements.</p> RETURNS DESCRIPTION <code>KeplerianElements</code> <p>if <code>e &gt; 1</code>.</p> RAISES DESCRIPTION <code>* `ValueError` if `e == 1` (parabolic case unsupported by this conversion).</code>"},{"location":"api/orbit_type/cometary/#py_outfit.orbit_type.cometary.CometaryElements.to_equinoctial","title":"to_equinoctial","text":"<pre><code>to_equinoctial() -&gt; EquinoctialElements\n</code></pre> <p>Convert cometary \u2192 Equinoctial elements.</p> RETURNS DESCRIPTION <code>EquinoctialElements</code> <p>if <code>e &gt; 1</code></p> RAISES DESCRIPTION <code>* `ValueError` if `e == 1` (parabolic case unsupported by this conversion).</code>"},{"location":"api/orbit_type/equinoctial/","title":"Equinoctial Elements","text":""},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements","title":"py_outfit.orbit_type.equinoctial.EquinoctialElements","text":"<pre><code>EquinoctialElements(\n    reference_epoch: float,\n    semi_major_axis: float,\n    eccentricity_sin_lon: float,\n    eccentricity_cos_lon: float,\n    tan_half_incl_sin_node: float,\n    tan_half_incl_cos_node: float,\n    mean_longitude: float,\n)\n</code></pre> <p>Equinoctial orbital elements.</p> Definitions <ul> <li><code>h = e * sin(\u03d6)</code> with \u03d6 = \u03a9 + \u03c9</li> <li><code>k = e * cos(\u03d6)</code></li> <li><code>p = tan(i/2) * sin(\u03a9)</code></li> <li><code>q = tan(i/2) * cos(\u03a9)</code></li> <li><code>\u03bb</code> (here <code>mean_longitude</code>) = mean longitude (rad), i.e. \u03a9 + \u03c9 + M in the usual convention</li> </ul> Units <ul> <li><code>reference_epoch</code>: MJD (TDB)</li> <li><code>semi_major_axis</code>: AU</li> <li><code>h</code>, <code>k</code>, <code>p</code>, <code>q</code>: dimensionless</li> <li><code>mean_longitude</code>: radians</li> </ul> See also <ul> <li><code>to_keplerian</code> \u2014 Convert to Keplerian elements.</li> </ul> RETURNS DESCRIPTION <code>EquinoctialElements</code> <p>A new equinoctial element set.</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.reference_epoch","title":"reference_epoch  <code>property</code>","text":"<pre><code>reference_epoch: float\n</code></pre> <p>Reference epoch of the element set (MJD, TDB).</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.semi_major_axis","title":"semi_major_axis  <code>property</code>","text":"<pre><code>semi_major_axis: float\n</code></pre> <p>Semi-major axis a (AU).</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.eccentricity_sin_lon","title":"eccentricity_sin_lon  <code>property</code>","text":"<pre><code>eccentricity_sin_lon: float\n</code></pre> <p>h = e * sin(\u03d6), dimensionless.</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.eccentricity_cos_lon","title":"eccentricity_cos_lon  <code>property</code>","text":"<pre><code>eccentricity_cos_lon: float\n</code></pre> <p>k = e * cos(\u03d6), dimensionless.</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.tan_half_incl_sin_node","title":"tan_half_incl_sin_node  <code>property</code>","text":"<pre><code>tan_half_incl_sin_node: float\n</code></pre> <p>p = tan(i/2) * sin(\u03a9), dimensionless.</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.tan_half_incl_cos_node","title":"tan_half_incl_cos_node  <code>property</code>","text":"<pre><code>tan_half_incl_cos_node: float\n</code></pre> <p>q = tan(i/2) * cos(\u03a9), dimensionless.</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.mean_longitude","title":"mean_longitude  <code>property</code>","text":"<pre><code>mean_longitude: float\n</code></pre> <p>Mean longitude \u03bb (radians).</p>"},{"location":"api/orbit_type/equinoctial/#py_outfit.orbit_type.equinoctial.EquinoctialElements.to_keplerian","title":"to_keplerian","text":"<pre><code>to_keplerian() -&gt; KeplerianElements\n</code></pre> <p>Convert equinoctial \u2192 Keplerian elements.</p> RETURNS DESCRIPTION <code>KeplerianElements</code> <p>The equivalent Keplerian elements.</p>"},{"location":"api/orbit_type/keplerian/","title":"Keplerian Elements","text":""},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements","title":"py_outfit.orbit_type.keplerian.KeplerianElements","text":"<pre><code>KeplerianElements(\n    reference_epoch: float,\n    semi_major_axis: float,\n    eccentricity: float,\n    inclination: float,\n    ascending_node_longitude: float,\n    periapsis_argument: float,\n    mean_anomaly: float,\n)\n</code></pre> <p>Keplerian orbital elements.</p> Units <ul> <li><code>reference_epoch</code>: MJD (TDB)</li> <li><code>semi_major_axis</code>: AU</li> <li><code>eccentricity</code>: dimensionless</li> <li><code>inclination</code>: radians</li> <li><code>ascending_node_longitude</code> (\u03a9): radians</li> <li><code>periapsis_argument</code> (\u03c9): radians</li> <li><code>mean_anomaly</code> (M): radians</li> </ul> See also <ul> <li><code>to_equinoctial</code> \u2014 Convert to equinoctial elements.</li> </ul> RETURNS DESCRIPTION <code>KeplerianElements</code> <p>A new Keplerian element set.</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.reference_epoch","title":"reference_epoch  <code>property</code>","text":"<pre><code>reference_epoch: float\n</code></pre> <p>Reference epoch of the element set (MJD, TDB).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.semi_major_axis","title":"semi_major_axis  <code>property</code>","text":"<pre><code>semi_major_axis: float\n</code></pre> <p>Semi-major axis a (AU).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.eccentricity","title":"eccentricity  <code>property</code>","text":"<pre><code>eccentricity: float\n</code></pre> <p>Orbital eccentricity e (dimensionless).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.inclination","title":"inclination  <code>property</code>","text":"<pre><code>inclination: float\n</code></pre> <p>Inclination i (radians).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.ascending_node_longitude","title":"ascending_node_longitude  <code>property</code>","text":"<pre><code>ascending_node_longitude: float\n</code></pre> <p>Longitude of ascending node \u03a9 (radians).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.periapsis_argument","title":"periapsis_argument  <code>property</code>","text":"<pre><code>periapsis_argument: float\n</code></pre> <p>Argument of periapsis \u03c9 (radians).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.mean_anomaly","title":"mean_anomaly  <code>property</code>","text":"<pre><code>mean_anomaly: float\n</code></pre> <p>Mean anomaly M (radians).</p>"},{"location":"api/orbit_type/keplerian/#py_outfit.orbit_type.keplerian.KeplerianElements.to_equinoctial","title":"to_equinoctial","text":"<pre><code>to_equinoctial() -&gt; EquinoctialElements\n</code></pre> <p>Convert keplerian \u2192 equinoctial elements.</p> RETURNS DESCRIPTION <code>EquinoctialElements</code> <p>The equivalent equinoctial elements.</p>"},{"location":"tutorials/iod_params/","title":"IODParams: configuring Gauss IOD","text":"<p>This tutorial explains the purpose of <code>IODParams</code>, how it shapes the Gauss Initial Orbit Determination (IOD) pipeline, and practical ways to configure it for different datasets. The goal is to keep configuration centralized, reproducible, and explicit.</p>"},{"location":"tutorials/iod_params/#what-iodparams-is-for","title":"What IODParams is for","text":"<p><code>IODParams</code> collects all tunable parameters used by the Gauss IOD solver. It controls how observation triplets are selected, how Monte Carlo perturbations are applied, which physical and numerical filters are enforced, and how candidate solutions are ranked by RMS. The same parameter object can be reused across many trajectories and batches for consistent behavior.</p> <p>At a high level, the pipeline proceeds by generating triplets from time-ordered observations, expanding them via controlled noise, solving the Gauss polynomial to obtain candidate orbits, filtering candidates by physical plausibility and numerical quality, and selecting the best solution by RMS over a controlled time window.</p>"},{"location":"tutorials/iod_params/#getting-a-configuration","title":"Getting a configuration","text":"<p>You can either instantiate <code>IODParams()</code> to get the defaults, or use the fluent builder to override only what you need before producing an immutable configuration.</p> IODParams defaults<pre><code># IODParams defaults: obtain the standard configuration\nfrom py_outfit import IODParams\n\n# All fields are initialized to the documented defaults\nparams = IODParams()\nprint(params.max_triplets, params.dtmax, params.n_noise_realizations)\n</code></pre> <p>The defaults are conservative and intended to work on a wide range of small datasets. For larger data or specific science goals, it is common to change the number of triplets, the extrapolation window for RMS, and parallel execution.</p>"},{"location":"tutorials/iod_params/#turning-on-parallel-execution","title":"Turning on parallel execution","text":"<p>Parallel execution can reduce wall-clock time for many trajectories. The advisory flag is carried by <code>IODParams</code> and consumed by higher-level APIs that accept it.</p> Requesting parallel execution<pre><code># Request parallel execution when supported by the build\nfrom py_outfit import IODParams\n\nparams = (\n    IODParams.builder()\n    .do_parallel()    # advisory flag consumed by higher-level APIs\n    .batch_size(8)  # number of trajectories to schedule at once\n    .build()\n)\nprint(params.do_parallel, params.batch_size)\n</code></pre> <p>When processing many trajectories, prefer larger batch sizes (for example, 500\u20131000), because the overhead of assembling and scheduling batches can dominate when batches are too small. In sequential mode, cooperative cancellation (Ctrl\u2011C) remains responsive; in parallel mode, cancellation is not supported and you may need to terminate the process to stop long runs.</p>"},{"location":"tutorials/iod_params/#physical-and-numerical-filters","title":"Physical and numerical filters","text":"<p>The Gauss pipeline produces multiple mathematical candidates per triplet. <code>IODParams</code> constrains the search to physically plausible and numerically stable regions, which prevents spurious or degenerate solutions.</p> Plausibility and solver tolerances<pre><code># Tune physical and numerical filters for the Gauss solver\nfrom py_outfit import IODParams\n\nparams = (\n    IODParams.builder()\n    # Physical plausibility\n    .max_ecc(3.0)\n    .max_perihelion_au(100.0)\n    .r2_min_au(0.1)\n    .r2_max_au(100.0)\n    .min_rho2_au(0.02)\n    # Numerical tolerances\n    .aberth_max_iter(100)\n    .aberth_eps(1e-8)\n    .newton_eps(1e-12)\n    .newton_max_it(75)\n    .kepler_eps(1e-12)\n    .root_imag_eps(1e-8)\n    .max_tested_solutions(5)\n    .build()\n)\nprint(\n    params.max_ecc,\n    params.aberth_max_iter,\n    params.max_tested_solutions,\n)\n</code></pre> <ul> <li>Physical constraints (eccentricity, perihelion, heliocentric distance bounds, minimum topocentric distance) help reduce non-physical or near-observer pathologies.</li> <li>Numerical tolerances for the Aberth\u2013Ehrlich polynomial solver, Newton steps, and the universal Kepler solver govern convergence and robustness. The parameter <code>root_imag_eps</code> controls how small the imaginary part of a complex root must be to treat it as effectively real when selecting roots of the 8th\u2011degree Gauss polynomial. The bounds <code>r2_min_au</code> and <code>r2_max_au</code> apply plausibility constraints to the central heliocentric distance used during root selection. The parameter <code>min_rho2_au</code> rejects spurious geometries by enforcing a minimum topocentric distance at the central epoch.</li> </ul>"},{"location":"tutorials/iod_params/#rms-window-and-triplet-selection","title":"RMS window and triplet selection","text":"<p>RMS evaluation is carried out over a time window derived from the triplet span and clamped to a minimum. Triplet generation itself is constrained by minimum and maximum spans and a target spacing.</p> RMS window and triplet spacing<pre><code># Control the RMS evaluation window and triplet spacing\nfrom py_outfit import IODParams\n\nparams = (\n    IODParams.builder()\n    .extf(2.0)              # scale relative to triplet span\n    .dtmax(45.0)            # floor in days for evaluation window\n    .dt_min(0.05)           # shortest allowed triplet span\n    .dt_max_triplet(120.0)  # longest allowed triplet span\n    .optimal_interval_time(15.0)\n    .max_triplets(50)\n    .gap_max(6.0/24.0)\n    .build()\n)\nprint(params.extf, params.dtmax, params.max_triplets)\n</code></pre> <p>The RMS window is derived from the triplet span and clamped to a minimum: <code>dt_window = (last \u2212 first) \u00d7 extf</code>, with the final window ensured to be at least <code>dtmax</code>. Use a negative <code>extf</code> to trigger a broad fallback window when observations are sparse or irregularly sampled. Increase <code>dtmax</code> if the default minimum window is too short for your cadence.</p>"},{"location":"tutorials/iod_params/#practical-guidance","title":"Practical guidance","text":"<ul> <li>Prefer the builder for clarity and reproducibility; only set what you need.</li> <li>Start from defaults, adjust triplet and RMS controls first, then refine physical and numerical filters.</li> <li>Enable parallelism for large batches; keep sequential mode for small, interactive runs so that cancellation remains responsive.</li> <li>Use a fixed seed when you need bitwise reproducibility across runs.</li> </ul>"},{"location":"tutorials/iod_params/#validation-and-special-cases","title":"Validation and special cases","text":"<p><code>IODParams</code> is validated when built to prevent inconsistent configurations. Time spans must be non\u2011negative; tolerances must be positive; and plausibility bounds must be ordered and strictly positive. Two special cases are worth noting. First, setting <code>n_noise_realizations = 0</code> disables noisy clones and uses only the original triplet, which can be useful for speed\u2011of\u2011light checks or deterministic baselines. Second, <code>max_obs_for_triplets &lt; 3</code> is accepted and behaves like <code>3</code>, effectively selecting first/middle/last so that at least one valid triplet is always available. Negative <code>extf</code> activates the broad fallback window; regardless of <code>extf</code>, the RMS window is clamped to be at least <code>dtmax</code>.</p>"},{"location":"tutorials/iod_params/#tuning-cheat-sheet","title":"Tuning cheat sheet","text":"<ul> <li>Too many spurious candidates or unstable solutions: tighten <code>max_ecc</code>, decrease <code>r2_max_au</code>, increase <code>min_rho2_au</code>, or reduce <code>root_imag_eps</code>.</li> <li>Convergence issues on some datasets: raise <code>aberth_max_iter</code> moderately and relax <code>aberth_eps</code> slightly; check <code>newton_eps</code>/<code>newton_max_it</code> and <code>kepler_eps</code>.</li> <li>Sparse or irregular sampling: use a negative <code>extf</code> or increase <code>dtmax</code>; increase <code>dt_min</code> to avoid ultra\u2011short triplets.</li> <li>Large volume batches: enable <code>.do_parallel()</code> and increase <code>batch_size</code>; prefer larger batch sizes (hundreds to a thousand) to amortize scheduling overhead.</li> </ul>"},{"location":"tutorials/orbit_results/","title":"Working with orbit results (Gauss IOD)","text":"<p>This tutorial shows how to consume the successful results returned by <code>TrajectorySet.estimate_all_orbits(...)</code> and how to navigate the different orbital element families produced by the Gauss solver.</p> <p>You will learn how to:</p> <ul> <li>iterate over the successful results map and inspect <code>GaussResult</code> objects,</li> <li>check whether the result is a preliminary or corrected orbit,</li> <li>extract the concrete orbital elements (Keplerian, Equinoctial, or Cometary),</li> <li>convert between element families when supported,</li> <li>serialize results to dictionaries for logging or downstream processing.</li> </ul> <p>The examples assume you already ran batch IOD and obtained <code>(ok, errors)</code> from <code>estimate_all_orbits(env, params, ...)</code>. See the Trajectories and IODParams tutorials for how to configure and run the solver.</p> Reference: run_iod() used by the snippets <p>The code examples below call a shared helper that builds a small dataset, runs batch IOD, and returns <code>(ok, errors)</code>. For completeness, here is the helper once:</p> common_tuto.run_iod()<pre><code>from py_outfit import PyOutfit, IODParams, TrajectorySet, Observer\nimport numpy as np\nfrom astropy.time import Time\n\n\ndef run_iod():\n    env = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n    obs = Observer(\n        0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3 / 3600.0), np.deg2rad(0.3 / 3600.0)\n    )\n    env.add_observer(obs)\n\n    trajectory_id = np.array(\n        [\n            0,\n            1,\n            2,\n            1,\n            2,\n            1,\n            0,\n            0,\n            0,\n            1,\n            2,\n            1,\n            1,\n            0,\n            2,\n            2,\n            0,\n            2,\n            2,\n            10,\n            10,\n            10,\n            11,\n            11,\n            11,\n        ],\n        dtype=np.uint32,\n    )\n    ra_deg = np.array(\n        [\n            20.9191548,\n            33.4247141,\n            32.1435128,\n            33.4159091,\n            32.1347282,\n            33.3829299,\n            20.6388309,\n            20.6187259,\n            20.6137886,\n            32.7525147,\n            31.4874917,\n            32.4518231,\n            32.4495403,\n            19.8927380,\n            30.6416348,\n            30.0938936,\n            18.2218784,\n            28.3859403,\n            28.3818327,\n            10.0,\n            10.01,\n            10.02,\n            180.0,\n            180.02,\n            180.05,\n        ]\n    )\n    dec_deg = np.array(\n        [\n            20.0550441,\n            23.5516817,\n            26.5139615,\n            23.5525348,\n            26.5160622,\n            23.5555991,\n            20.1218532,\n            20.1264229,\n            20.1275173,\n            23.6064063,\n            26.6622284,\n            23.6270392,\n            23.6272157,\n            20.2977473,\n            26.8303010,\n            26.9256271,\n            20.7096409,\n            27.1602652,\n            27.1606420,\n            5.0,\n            5.01,\n            5.015,\n            -10.0,\n            -10.02,\n            -10.03,\n        ]\n    )\n    times_jd_utc = np.array(\n        [\n            2458789.6362963,\n            2458789.6381250,\n            2458789.6381250,\n            2458789.6663773,\n            2458789.6663773,\n            2458789.7706481,\n            2458790.6995023,\n            2458790.7733333,\n            2458790.7914120,\n            2458791.8445602,\n            2458791.8445602,\n            2458792.8514699,\n            2458792.8590741,\n            2458793.6896759,\n            2458794.7996759,\n            2458796.7965162,\n            2458801.7863426,\n            2458803.7699537,\n            2458803.7875231,\n            2458800.0,\n            2458800.01,\n            2458800.03,\n            2458800.0,\n            2458800.02,\n            2458800.05,\n        ]\n    )\n\n    # Convert times to MJD (TT) using astropy\n    t_utc = Time(times_jd_utc, format=\"jd\", scale=\"utc\")\n    mjd_tt = t_utc.tt.mjd.astype(np.float64)\n\n    # Degree path performs a single conversion to radians at ingestion\n    ts = TrajectorySet.from_numpy_degrees(\n        env,\n        trajectory_id,\n        ra_deg,\n        dec_deg,\n        error_ra_arcsec=0.3,\n        error_dec_arcsec=0.3,\n        mjd_tt=mjd_tt,\n        observer=obs,\n    )\n\n    # Configure IOD and run batch estimation\n    params = IODParams.builder().max_triplets(200).do_sequential().build()\n    ok, errors = ts.estimate_all_orbits(env, params, seed=42)\n\n    return ok, errors\n</code></pre>"},{"location":"tutorials/orbit_results/#iterate-over-successful-results","title":"Iterate over successful results","text":"Iterate results<pre><code># Iterate over successful Gauss results and print stage + RMS\nfrom common_tuto import run_iod\n\nok, errors = run_iod()\n\nif not ok:\n    print(\"No successful results; errors:\", errors)\nelse:\n    for obj_id, (g_res, rms) in ok.items():\n        stage = \"corrected\" if g_res.is_corrected() else \"preliminary\"\n        print(f\"Object {obj_id}: stage={stage}, RMS={rms:.6e} rad\")\n</code></pre> <ul> <li><code>obj_id</code> is the same identifier you used when ingesting trajectories (int or str).</li> <li><code>rms</code> is the post-fit residual RMS (radians) computed over the chosen time window.</li> </ul>"},{"location":"tutorials/orbit_results/#determine-the-element-family","title":"Determine the element family","text":"Family and stage<pre><code># Determine element family and stage from one successful result\nfrom common_tuto import run_iod\n\nok, errors = run_iod()\n\nif ok:\n    obj_id, (g_res, rms) = next(iter(ok.items()))\n    fam = g_res.elements_type()\n    stage = \"corrected\" if g_res.is_corrected() else \"preliminary\"\n    print(obj_id, fam, stage)\nelse:\n    print(\"No successful results; cannot show family/stage example.\")\n</code></pre>"},{"location":"tutorials/orbit_results/#extract-concrete-elements","title":"Extract concrete elements","text":"<p>Use the typed accessors; they return <code>None</code> if the stored family differs.</p> Extract typed elements<pre><code># Extract concrete orbital elements from a GaussResult\nfrom common_tuto import run_iod\n\nok, _ = run_iod()\n\nif ok:\n    _, (g_res, rms) = next(iter(ok.items()))\n    k = g_res.keplerian()\n    q = g_res.equinoctial()\n    c = g_res.cometary()\n    if k is not None:\n        print(\"K a,e:\", k.semi_major_axis, k.eccentricity)\n    if q is not None:\n        print(\"Q a,h,k:\", q.semi_major_axis, q.eccentricity_sin_lon, q.eccentricity_cos_lon)\n    if c is not None:\n        print(\"C q,e:\", c.perihelion_distance, c.eccentricity)\nelse:\n    print(\"No successful results; cannot extract element examples.\")\n</code></pre> <p>Units reminder: - Epochs are MJD (TDB). Angles are radians. Distances are AU.</p>"},{"location":"tutorials/orbit_results/#convert-between-element-families","title":"Convert between element families","text":"<p>Conversions are provided by the element classes themselves.</p> <ul> <li>Keplerian \u2192 Equinoctial:</li> </ul> Convert between families<pre><code># Convert between orbital element families\nfrom common_tuto import run_iod\n\nok, _ = run_iod()\n\nif ok:\n    _, (g_res, _) = next(iter(ok.items()))\n    k = g_res.keplerian()\n    q = g_res.equinoctial()\n    c = g_res.cometary()\n\n    if k is not None:\n        q2 = k.to_equinoctial()\n        print(\"K\u2192Q a,\u03bb:\", q2.semi_major_axis, q2.mean_longitude)\n    if q is not None:\n        k2 = q.to_keplerian()\n        print(\"Q\u2192K a,e:\", k2.semi_major_axis, k2.eccentricity)\n    if c is not None and c.eccentricity &gt; 1.0:\n        k_h = c.to_keplerian()\n        print(\"C(hyperbolic)\u2192K a,e:\", k_h.semi_major_axis, k_h.eccentricity)\nelse:\n    print(\"No successful results; cannot demonstrate conversions.\")\n</code></pre> <p>Note: parabolic cometary elements (e = 1) cannot be converted by these helpers and will raise a <code>ValueError</code>.</p>"},{"location":"tutorials/orbit_results/#structured-dict-serialization","title":"Structured dict serialization","text":"<p>Every <code>GaussResult</code> can be converted to a plain dictionary for easy logging and JSON export:</p> Structured dict serialization<pre><code># Serialize a GaussResult to a structured dict\nfrom common_tuto import run_iod\n\nok, _ = run_iod()\n\nif ok:\n    _, (g_res, _) = next(iter(ok.items()))\n    d = g_res.to_dict()\n    print(d[\"stage\"], d[\"type\"], sorted(d[\"elements\"].keys()))\nelse:\n    print(\"No successful results; cannot show to_dict().\")\n</code></pre> <p>Example for a Keplerian result:</p> <pre><code>{\n    'stage': 'corrected', \n    'type': 'keplerian', \n    'elements': {\n        'reference_epoch': 58794.29503864708, \n        'semi_major_axis': 2.618543557694562, \n        'eccentricity': 0.2917924222538649, \n        'inclination': 0.23168624097364912, \n        'ascending_node_longitude': 0.20856161706357348, \n        'periapsis_argument': 6.264575557486691, \n        'mean_anomaly': 0.29001350766154466\n    }\n}\n</code></pre>"},{"location":"tutorials/orbit_results/#putting-it-together-filter-convert-export","title":"Putting it together: filter, convert, export","text":"<p>Below is a compact pattern you can adapt to your pipeline:</p> Filter, convert, export<pre><code># Filter, convert, and build a plain export from successful results\nfrom common_tuto import run_iod\n\nok, _ = run_iod()\n\nexport = []\nfor obj_id, (g_res, rms) in ok.items():\n    k = g_res.keplerian()\n    if k is None:\n        q = g_res.equinoctial()\n        if q is not None:\n            k = q.to_keplerian()\n        else:\n            c = g_res.cometary()\n            if c is not None and c.eccentricity &gt; 1.0:\n                k = c.to_keplerian()\n\n    if k is None:\n        d = g_res.to_dict()\n        export.append({\"id\": obj_id, \"rms\": rms, **d})\n    else:\n        export.append({\n            \"id\": obj_id,\n            \"rms\": rms,\n            \"stage\": \"corrected\" if g_res.is_corrected() else \"preliminary\",\n            \"type\": \"keplerian\",\n            \"a_au\": k.semi_major_axis,\n            \"e\": k.eccentricity,\n            \"i_rad\": k.inclination,\n            \"Omega_rad\": k.ascending_node_longitude,\n            \"omega_rad\": k.periapsis_argument,\n            \"M_rad\": k.mean_anomaly,\n            \"epoch_mjd_tdb\": k.reference_epoch,\n        })\n\nprint(len(export))\n</code></pre>"},{"location":"tutorials/orbit_results/#tips","title":"Tips","text":"<ul> <li>Always check the element family via <code>elements_type()</code> before calling accessors; the typed helpers return <code>None</code> when mismatched.</li> <li>When you need a single canonical representation, prefer converting to Keplerian where defined, but keep native cometary elements for <code>e = 1</code>.</li> <li>Store the RMS alongside the elements; it\u2019s a useful quality metric for ranking and filtering.</li> <li>If you run <code>estimate_best_orbit</code> repeatedly on the same <code>Observations</code> instance, be aware of the in-place uncertainty scaling caveat described in the Observations tutorial; recreate the object for bitwise reproducibility.</li> </ul>"},{"location":"tutorials/pandas_tuto/","title":"Pandas integration: vectorized IOD from DataFrames","text":"<p>This tutorial shows how to run Gauss IOD directly from a flat Pandas DataFrame via the <code>DataFrame.outfit</code> accessor. You will learn how to:</p> <ul> <li>initialize the environment and register the accessor,</li> <li>run the degrees+arcseconds workflow,</li> <li>use a radians workflow,</li> <li>adapt to custom column names with <code>Schema</code>,</li> <li>handle successes and errors, and join results with external metadata.</li> </ul> <p>The accessor is implemented in <code>py_outfit.pandas_pyoutfit</code> and builds a <code>TrajectorySet</code> from NumPy arrays under the hood.</p>"},{"location":"tutorials/pandas_tuto/#prerequisites","title":"Prerequisites","text":"<p>Importing the module registers the accessor and we create a simple observing environment:</p> Setup environment and accessor<pre><code>\"\"\"\nEnvironment and observer setup for the Pandas tutorial.\n\nThis snippet creates a computation environment and registers a simple\nobserving site. Importing `py_outfit.pandas_pyoutfit` registers the\n`DataFrame.outfit` accessor.\n\"\"\"\n\nfrom py_outfit import PyOutfit, Observer\nimport numpy as np\n\n# Accessor registration (side\u2011effect import)\nimport py_outfit.pandas_pyoutfit  # noqa: F401\n\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n\nobserver = Observer(\n    longitude=0.0,  # degrees east\n    latitude=0.0,   # degrees\n    elevation=1.0,  # kilometers\n    name=\"DemoSite\",\n    ra_accuracy=np.deg2rad(0.3 / 3600.0),  # radians\n    dec_accuracy=np.deg2rad(0.3 / 3600.0),  # radians\n)\nenv.add_observer(observer)\n\nprint(env.show_observatories())\n</code></pre>"},{"location":"tutorials/pandas_tuto/#degrees-arcseconds-workflow","title":"Degrees + arcseconds workflow","text":"<p>Your DataFrame provides <code>tid</code>, <code>mjd</code>, <code>ra</code>, <code>dec</code>. Angles are degrees and uncertainties are provided in arcseconds.</p> Minimal example (degrees + arcsec)<pre><code>\"\"\"\nMinimal degrees+arcseconds workflow using the Pandas accessor.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom py_outfit import IODParams\n\n# Ensure the accessor is registered\nimport py_outfit.pandas_pyoutfit  # noqa: F401\n\nfrom pandas_setup import env, observer  # type: ignore\n\n\n# Build a tiny demo dataset: three objects, three observations each\ndf = pd.DataFrame(\n    {\n        \"tid\": [0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2],\n        \"mjd\": [\n            58789.13709704,\n            58790.20030304,\n            58790.27413404,\n            58790.29221274,\n            58793.19047664,\n            58801.28714334,\n            60000.0,\n            60000.02,\n            60000.05,\n            60000.0,\n            60000.02,\n            60000.05,\n        ],\n        \"ra\": [\n            20.9191548,\n            20.6388309,\n            20.6187259,\n            20.6137886,\n            19.8927380,\n            18.2218784,\n            33.42,\n            33.44,\n            33.47,\n            32.14,\n            32.17,\n            32.20,\n        ],\n        \"dec\": [\n            20.0550441,\n            20.1218532,\n            20.1264229,\n            20.1275173,\n            20.2977473,\n            20.7096409,\n            23.55,\n            23.56,\n            23.57,\n            26.51,\n            26.52,\n            26.53,\n        ],\n    }\n)\n\nparams = IODParams.builder().max_triplets(150).do_sequential().build()\n\nres = df.outfit.estimate_orbits(\n    env,\n    params,\n    observer,\n    ra_error=0.3,  # arcsec\n    dec_error=0.3,  # arcsec\n    units=\"degrees\",\n    rng_seed=42,\n)\n\n# Show a compact preview, resilient to error-only outputs\nwanted = [\"object_id\", \"variant\", \"element_set\", \"rms\", \"status\", \"error\"]\ncols = [c for c in wanted if c in res.columns]\nprint(res.head(5)[cols])\n</code></pre> <p>Notes</p> <ul> <li>Internally, RA/DEC are converted once to radians; uncertainties are converted from arcsec to radians using <code>RADSEC</code>.</li> <li>Use <code>rng_seed</code> for deterministic exploration.</li> </ul>"},{"location":"tutorials/pandas_tuto/#radians-workflow","title":"Radians workflow","text":"<p>Supply angles and uncertainties in radians to avoid conversions.</p> Radians end-to-end<pre><code>\"\"\"\nRadians workflow: supply RA/DEC and uncertainties in radians.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom py_outfit import IODParams\n\nimport py_outfit.pandas_pyoutfit  # noqa: F401\nfrom pandas_setup import env, observer  # type: ignore\n\n\narcsec = np.deg2rad(1.0 / 3600.0)\n\ndf_rad = pd.DataFrame(\n    {\n        \"tid\": [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n        \"mjd\": [\n            58789.13709704,\n            58790.20030304,\n            58790.27413404,\n            58790.29221274,\n            58793.19047664,\n            58801.28714334,\n        ],\n        \"ra\": np.deg2rad(\n            [\n                20.9191548,\n                20.6388309,\n                20.6187259,\n                20.6137886,\n                19.8927380,\n                18.2218784,\n            ]\n        ),\n        \"dec\": np.deg2rad(\n            [\n                20.0550441,\n                20.1218532,\n                20.1264229,\n                20.1275173,\n                20.2977473,\n                20.7096409,\n            ]\n        ),\n    }\n)\n\nparams = IODParams()\n\nres = df_rad.outfit.estimate_orbits(\n    env,\n    params,\n    observer,\n    ra_error=0.3 * arcsec,  # radians\n    dec_error=0.3 * arcsec,  # radians\n    units=\"radians\",\n    rng_seed=7,\n)\n\nprint(res[[\"object_id\", \"variant\", \"element_set\", \"rms\"]])\n</code></pre>"},{"location":"tutorials/pandas_tuto/#custom-column-names-with-schema","title":"Custom column names with Schema","text":"<p>If your DataFrame uses different names, provide a <code>Schema</code> mapping.</p> Adapt to arbitrary column names<pre><code>\"\"\"\nCustom Schema: adapt to DataFrames with different column names.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom py_outfit import IODParams\nfrom py_outfit.pandas_pyoutfit import Schema\n\nimport py_outfit.pandas_pyoutfit  # noqa: F401\nfrom pandas_setup import env, observer  # type: ignore\n\n\ndf_weird = pd.DataFrame(\n    {\n        \"object\": [0, 0, 0, 0, 0, 0],\n        \"epoch\": [\n            58789.13709704,\n            58790.20030304,\n            58790.27413404,\n            58790.29221274,\n            58793.19047664,\n            58801.28714334,\n        ],\n        \"alpha\": [\n            20.9191548,\n            20.6388309,\n            20.6187259,\n            20.6137886,\n            19.8927380,\n            18.2218784,\n        ],\n        \"delta\": [\n            20.0550441,\n            20.1218532,\n            20.1264229,\n            20.1275173,\n            20.2977473,\n            20.7096409,\n        ],\n    }\n)\n\nschema = Schema(tid=\"object\", mjd=\"epoch\", ra=\"alpha\", dec=\"delta\")\nparams = IODParams()\n\nres = df_weird.outfit.estimate_orbits(\n    env,\n    params,\n    observer,\n    ra_error=0.3,\n    dec_error=0.3,\n    schema=schema,\n    units=\"degrees\",\n)\n\nprint(res[[\"object_id\", \"variant\", \"element_set\", \"rms\"]])\n</code></pre>"},{"location":"tutorials/pandas_tuto/#handling-successes-and-errors-joining-metadata","title":"Handling successes and errors, joining metadata","text":"<p>The accessor returns a success table and may append error rows. You can split and join with other tables.</p> Post-processing: statuses and joins<pre><code>\"\"\"\nHandling status: split successes and errors, join back to metadata.\n\"\"\"\n\nimport pandas as pd\nfrom py_outfit import IODParams\n\nimport py_outfit.pandas_pyoutfit  # noqa: F401\nfrom pandas_setup import env, observer  # type: ignore\n\n\n# Small dataset with two objects, one might fail depending on config\ndata = {\n    \"tid\": [0, 0, 0, 0, 0, 0, 101, 101, 101],\n    \"mjd\": [\n        58789.13709704,\n        58790.20030304,\n        58790.27413404,\n        58790.29221274,\n        58793.19047664,\n        58801.28714334,\n        60030.0,\n        60030.01,\n        60030.02,\n    ],\n    \"ra\": [\n        20.9191548,\n        20.6388309,\n        20.6187259,\n        20.6137886,\n        19.8927380,\n        18.2218784,\n        220.0,\n        220.01,\n        219.99,\n    ],\n    \"dec\": [\n        20.0550441,\n        20.1218532,\n        20.1264229,\n        20.1275173,\n        20.2977473,\n        20.7096409,\n        -2.0,\n        -1.99,\n        -2.02,\n    ],\n}\ndf = pd.DataFrame(data)\n\nmeta = pd.DataFrame({\"tid\": [0, 101], \"mag\": [20.1, 21.3]})\n\nparams = IODParams.builder().max_triplets(200).do_sequential().build()\n\nout = df.outfit.estimate_orbits(\n    env, params, observer, ra_error=0.3, dec_error=0.3, units=\"degrees\", rng_seed=1\n)\n\nstatus = out[\"status\"] if \"status\" in out.columns else pd.Series(\"ok\", index=out.index)\nok = out[status == \"ok\"].copy()\nerr = out[status == \"error\"].copy()\n\nok_cols = [c for c in [\"object_id\", \"rms\", \"element_set\"] if c in ok.columns]\nprint(\"OK rows:\\n\", ok[ok_cols])\nprint(\"Errors:\\n\", err)\n\n# Join successes to external metadata (left join by identifier)\nok = ok.merge(meta, left_on=\"object_id\", right_on=\"tid\", how=\"left\")\nprint(ok[[\"object_id\", \"mag\", \"rms\"]])\n</code></pre>"},{"location":"tutorials/pandas_tuto/#caveats-and-reproducibility","title":"Caveats and reproducibility","text":"<ul> <li>Known backend caveat: due to an upstream issue in batch RMS correction, per\u2011observation uncertainties may be modified in place during a run. Re-using the same <code>Observations</code> instance and calling <code>estimate_best_orbit</code> repeatedly can yield different RMS between calls. When using the accessor this is typically not visible, but for strict reproducibility recreate the underlying <code>TrajectorySet</code> or source DataFrame before repeated runs.</li> <li><code>rng_seed</code> ensures deterministic random sampling but does not prevent in-place mutations from earlier runs.</li> </ul>"},{"location":"tutorials/pandas_tuto/#see-also","title":"See also","text":"<ul> <li>API reference: <code>Pandas Integration</code></li> <li>Core container: <code>TrajectorySet</code></li> <li>Configuration: <code>IODParams</code> tutorial</li> </ul>"},{"location":"tutorials/pyoutfit_environment/","title":"pyOutfit Environment","text":"<p>This tutorial introduces the <code>PyOutfit</code> environment object and explains its role as the central coordination point for ephemerides, error models, and observatory management. It also outlines how the environment interacts with observations and batch orbit determination.</p>"},{"location":"tutorials/pyoutfit_environment/#purpose-of-pyoutfit","title":"Purpose of <code>PyOutfit</code>","text":"<p><code>PyOutfit</code> encapsulates the configuration needed by the Outfit core engine to perform initial orbit determination and related computations. It holds the selected planetary ephemerides, the astrometric error model, and a registry of observatories. Other components, such as <code>TrajectorySet</code>, rely on an initialized environment to resolve observer geometry, reference frames, and numerical settings consistently.</p> <p>In typical workflows, a single <code>PyOutfit</code> instance is created at the beginning of a session or pipeline and passed to ingestion and batch-processing functions. This pattern ensures consistent context across all computations and avoids duplicating configuration.</p>"},{"location":"tutorials/pyoutfit_environment/#key-responsibilities","title":"Key responsibilities","text":"<ul> <li>Manage ephemerides selection (e.g., DE440) used for precise solar-system positions.</li> <li>Provide a registry for <code>Observer</code> definitions, either fetched from MPC codes or created manually.</li> <li>Serve as a context object for ingestion of observations and for batch estimation of orbits.</li> <li>Expose convenience utilities for listing and validating available observatories.</li> </ul>"},{"location":"tutorials/pyoutfit_environment/#typical-usage-pattern","title":"Typical usage pattern","text":"<ul> <li>Initialize the environment with an ephemerides selector and an astrometric error model string.</li> <li>Register at least one <code>Observer</code> that represents the observing site used in your data.</li> <li>Ingest observations into a <code>TrajectorySet</code>, using either radian-based zero\u2011copy arrays, degree-based arrays with conversion, or supported file formats.</li> <li>Configure <code>IODParams</code> and run batch Gauss IOD, passing the environment and parameters.</li> </ul>"},{"location":"tutorials/pyoutfit_environment/#example-snippets","title":"Example snippets","text":"<p>Below are non-executable snippets demonstrating the expected structure of a session. The code is provided in separate files and included here for readability.</p>"},{"location":"tutorials/pyoutfit_environment/#environment-initialization","title":"Environment initialization","text":"Minimal environment setup<pre><code># Environment initialization example for documentation inclusion\nfrom py_outfit import PyOutfit\n\n# Create a new environment with ephemerides and an error model\n# The error model string controls observational uncertainty handling in the core engine\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\") # (1) ephemerides selector, error model\n\n# Human-readable listing of currently known observatories (initially empty or built-in)\nprint(env.show_observatories())\n</code></pre> <ol> <li>The constructor accepts two strings: an ephemerides selector and an astrometric error model. The ephemerides selector uses the format \"{source}:{version}\" and recognizes two backends: \"horizon\" for legacy JPL DE binaries and \"naif\" for NAIF SPK/DAF kernels. Examples include \"horizon:DE440\" and \"naif:DE440\". The resolved file is stored under the OS cache (e.g., ~/.cache/outfit_cache/jpl_ephem/\u2026), and when the build enables JPL downloads, a missing file is fetched automatically; otherwise an error is raised. The error model selects per\u2011site RA/DEC bias and RMS tables used during orbit determination. Supported names include \"FCCT14\", \"VFCC17\", and \"CBM10\"; unknown names default to \"FCCT14\". These two parameters define the numerical and physical context shared by ingestion and IOD routines.</li> </ol>"},{"location":"tutorials/pyoutfit_environment/#observer-registration","title":"Observer registration","text":"Observer registration<pre><code># Observer registration example for documentation inclusion\nfrom py_outfit import PyOutfit, Observer\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n\n# Define a custom observing site; elevation is expressed in kilometers\nobs = Observer(\n    longitude=12.345,  # degrees east\n    latitude=-5.0,     # degrees\n    elevation=1.0,     # kilometers above MSL\n    name=\"DemoSite\",\n    ra_accuracy=0.0,   # radians (optional, example value)\n    dec_accuracy=0.0,  # radians (optional, example value)\n)\n\n# Register the observer in the environment\nenv.add_observer(obs)\n\n# On the first use, you will see only the added custom site from below\nprint(env.show_observatories())\n</code></pre>"},{"location":"tutorials/pyoutfit_environment/#fetching-an-observer-from-an-mpc-code","title":"Fetching an observer from an MPC code","text":"<p>Often you already know the MPC observatory code (e.g. \"I41\" for ZTF at Palomar, \"807\" for Cerro Paranal, etc.). Instead of manually constructing an <code>Observer</code>, you can request a ready\u2011made instance from the internal registry using <code>get_observer_from_mpc_code</code>.</p> <p>On its first use the environment fetches and parses the MPC Observatory Codes HTML page (ObsCodes list) from the Minor Planet Center. The resulting table is cached in-memory for the remainder of the process, so subsequent lookups do not re-contact the network. If the network is unavailable on the very first lookup, an exception will be raised. Unknown codes also raise a <code>ValueError</code> (wrapping a Rust error). Retrieved observers can be used immediately for ingestion; explicit re\u2011registration is not required unless you are mixing them with custom user-defined sites.</p> Fetch from MPC<pre><code># Obtain the ZTF (Palomar) observatory by its MPC code\nztf = env.get_observer_from_mpc_code(\"I41\")  # returns an Observer instance\nprint(ztf)  # human-readable summary (code, name, geodetic position)\n\n# Listing available observatories (optional helper)\n# Now that the MPC code lookup has been used, the internal registry\n# has been populated with all MPC observatories, so the output is much longer.\nprint(env.show_observatories())  # table of currently known / registered sites\n</code></pre> <p>Notes:</p> <ul> <li>Returned observers are immutable handles exposing their geometry to the Rust core; you do not modify longitude/latitude/elevation after creation.</li> <li>If you need to introduce a completely custom site not present in the catalog, build an <code>Observer</code> manually and register it (see the previous section snippet) before ingestion.</li> </ul>"},{"location":"tutorials/pyoutfit_environment/#notes-on-configuration","title":"Notes on configuration","text":"<ul> <li>The ephemerides selector is a string understood by the Outfit core; consult the API reference for supported values. A common choice is an identifier referring to JPL DE series. The error model string controls how observational uncertainties are interpreted and propagated; unknown strings default to a standard model.</li> <li>The environment\u2019s observatory registry is independent of trajectory ingestion. Multiple observers can be registered, but an ingestion call typically associates a single observer with the new data. If observations originate from multiple sites, separate ingestion steps or containers are recommended.</li> <li><code>PyOutfit</code> does not itself perform orbit determination; instead, it supplies the context required by <code>TrajectorySet.estimate_all_orbits</code> and related functions. This separation keeps configuration centralized and computation modules focused.</li> </ul>"},{"location":"tutorials/pyoutfit_environment/#reliability-and-performance-considerations","title":"Reliability and performance considerations","text":"<ul> <li>The environment is lightweight to construct and is intended to be reused. Creating many separate environments for a single batch is unnecessary.</li> <li>Numerical work is performed in Rust and detached from the Python GIL. Parallel execution can be enabled through IOD configuration and is generally beneficial for large batches.</li> <li>Deterministic operation is available by providing a random seed to batch execution routines that support it.</li> </ul>"},{"location":"tutorials/pyoutfit_environment/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Consult the API pages for <code>PyOutfit</code> and <code>Observer</code> to explore available methods and parameters.</li> </ul>"},{"location":"tutorials/trajectories_tuto/","title":"Trajectories: loading data and running batch IOD","text":"<p>This tutorial shows how to work with <code>TrajectorySet</code>, the container for many objects with time\u2011ordered astrometric observations. You will learn how to:</p> <ul> <li>import trajectories from files (MPC 80\u2011column and ADES),</li> <li>build trajectories from in\u2011memory NumPy arrays,</li> <li>estimate preliminary orbits for all trajectories or just one.</li> </ul> <p>The heavy lifting is performed by the Rust engine; the Python API keeps things concise and composable.</p>"},{"location":"tutorials/trajectories_tuto/#prerequisites","title":"Prerequisites","text":"<p>You will need a global environment and at least one observing site:</p> Register an observing site<pre><code># Observer registration example for documentation inclusion\nfrom py_outfit import PyOutfit, Observer\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n\n# Define a custom observing site; elevation is expressed in kilometers\nobs = Observer(\n    longitude=12.345,  # degrees east\n    latitude=-5.0,     # degrees\n    elevation=1.0,     # kilometers above MSL\n    name=\"DemoSite\",\n    ra_accuracy=0.0,   # radians (optional, example value)\n    dec_accuracy=0.0,  # radians (optional, example value)\n)\n\n# Register the observer in the environment\nenv.add_observer(obs)\n\n# On the first use, you will see only the added custom site from below\nprint(env.show_observatories())\n\n# Obtain the ZTF (Palomar) observatory by its MPC code\nztf = env.get_observer_from_mpc_code(\"I41\")  # returns an Observer instance\nprint(ztf)  # human-readable summary (code, name, geodetic position)\n\n# Listing available observatories (optional helper)\n# Now that the MPC code lookup has been used, the internal registry\n# has been populated with all MPC observatories, so the output is much longer.\nprint(env.show_observatories())  # table of currently known / registered sites\n</code></pre> <p>Units used in this API: angles are radians unless stated otherwise; epochs are MJD (TT, days); uncertainties may be provided in arcseconds for convenience where noted.</p>"},{"location":"tutorials/trajectories_tuto/#import-from-files","title":"Import from files","text":""},{"location":"tutorials/trajectories_tuto/#mpc-80column","title":"MPC 80\u2011column","text":"<p>Create a set from a single MPC 80\u2011column file, or append into an existing set.</p> From MPC 80-column<pre><code># Import trajectories from an MPC 80-column file and append another\nfrom pathlib import Path\nfrom py_outfit import PyOutfit, TrajectorySet\n\n# Create environment (ephemerides + error model)\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n\n# Build from a single MPC 80-column file\nmpc_path = Path(\"tests/data/2015AB.obs\")\nts = TrajectorySet.new_from_mpc_80col(env, mpc_path)\nprint(\"n_traj=\", ts.number_of_trajectories(), \"total_obs=\", ts.total_observations())\n\n# Append from a second file (no de-duplication)\nmpc_path2 = Path(\"tests/data/33803.obs\")\nts.add_from_mpc_80col(env, mpc_path2)\n</code></pre> <p>Notes</p> <ul> <li>Input parsing mirrors the Rust engine. Avoid ingesting the same file twice: no de\u2011duplication is performed.</li> </ul>"},{"location":"tutorials/trajectories_tuto/#ades-json-or-xml","title":"ADES (JSON or XML)","text":"<p>When creating from ADES, you can provide global uncertainties (arcsec) if they are not specified per row.</p> From ADES (JSON/XML)<pre><code># Import trajectories from an ADES file (JSON or XML) and optionally append others\nfrom pathlib import Path\nfrom py_outfit import PyOutfit, TrajectorySet\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\n\nades_path = Path(\"tests/data/example_ades.xml\")\nts = TrajectorySet.new_from_ades(env, ades_path, error_ra_arcsec=0.3, error_dec_arcsec=0.3)\n\n# Append another ADES file into the same set (avoid re-ingesting the same file)\nts.add_from_ades(env, Path(\"tests/data/flat_ades.xml\"), 0.3, 0.3)\n</code></pre>"},{"location":"tutorials/trajectories_tuto/#build-from-inmemory-arrays","title":"Build from in\u2011memory arrays","text":"<p>Two ingestion helpers are available. Use degrees/arcseconds for convenience, or supply radians for a zero\u2011copy path.</p>"},{"location":"tutorials/trajectories_tuto/#degrees-arcseconds-converted-once-to-radians","title":"Degrees + arcseconds (converted once to radians)","text":"From NumPy (degrees + arcsec)<pre><code># Build a TrajectorySet from degrees/arcseconds and MJD(TT)\nimport numpy as np\nfrom py_outfit import PyOutfit, TrajectorySet, Observer\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\nobs = Observer(0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3/3600.0), np.deg2rad(0.3/3600.0))\nenv.add_observer(obs)\n\ntrajectory_id = np.array([10, 10, 10, 11, 11, 11], dtype=np.uint32)\nra_deg        = np.array([10.0, 10.01, 10.02, 180.0, 180.02, 180.05])\ndec_deg       = np.array([ 5.0,  5.01,  5.015, -10.0, -10.02, -10.03])\nmjd_tt        = np.array([60000.0, 60000.01, 60000.03, 60000.0, 60000.02, 60000.05])\n\n# Performs one conversion to radians under the hood\nts = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg,\n    dec_deg,\n    error_ra_arcsec=0.3,\n    error_dec_arcsec=0.3,\n    mjd_tt=mjd_tt,\n    observer=obs,\n)\n</code></pre>"},{"location":"tutorials/trajectories_tuto/#radians-zerocopy","title":"Radians (zero\u2011copy)","text":"From NumPy (radians, zero-copy)<pre><code># Build a TrajectorySet from radians (zero-copy) and MJD(TT)\nimport numpy as np\nfrom py_outfit import PyOutfit, TrajectorySet, Observer\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\nobs = Observer(0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3/3600.0), np.deg2rad(0.3/3600.0))\nenv.add_observer(obs)\n\ntrajectory_id = np.array([10, 10, 10, 11, 11, 11], dtype=np.uint32)\nra_deg        = np.array([10.0, 10.01, 10.02, 180.0, 180.02, 180.05])\ndec_deg       = np.array([ 5.0,  5.01,  5.015, -10.0, -10.02, -10.03])\nra_rad        = np.deg2rad(ra_deg)\ndec_rad       = np.deg2rad(dec_deg)\nmjd_tt        = np.array([60000.0, 60000.01, 60000.03, 60000.0, 60000.02, 60000.05])\n\n# Zero-copy path when inputs are already radians\nts = TrajectorySet.from_numpy_radians(\n    env,\n    trajectory_id,\n    ra_rad,\n    dec_rad,\n    error_ra_rad=np.deg2rad(0.3 / 3600.0),\n    error_dec_rad=np.deg2rad(0.3 / 3600.0),\n    mjd_tt=mjd_tt,\n    observer=obs,\n)\n</code></pre>"},{"location":"tutorials/trajectories_tuto/#estimate-orbits","title":"Estimate orbits","text":"<p>You can estimate preliminary orbits for all trajectories in a set, or for a single trajectory.</p>"},{"location":"tutorials/trajectories_tuto/#batch-over-all-trajectories","title":"Batch over all trajectories","text":"Batch IOD across the set<pre><code># Batch orbit estimation across all trajectories\nfrom py_outfit import PyOutfit, TrajectorySet, IODParams, Observer\nimport numpy as np\nfrom astropy.time import Time\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\nobs = Observer(\n    0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3 / 3600.0), np.deg2rad(0.3 / 3600.0)\n)\nenv.add_observer(obs)\n\n# Minimal synthetic data (single trajectory)\ntrajectory_id = np.array(\n    [0, 1, 2, 1, 2, 1, 0, 0, 0, 1, 2, 1, 1, 0, 2, 2, 0, 2, 2],\n    dtype=np.uint32,\n)\n\nra_deg = np.array(\n    [\n        20.9191548,\n        33.4247141,\n        32.1435128,\n        33.4159091,\n        32.1347282,\n        33.3829299,\n        20.6388309,\n        20.6187259,\n        20.6137886,\n        32.7525147,\n        31.4874917,\n        32.4518231,\n        32.4495403,\n        19.8927380,\n        30.6416348,\n        30.0938936,\n        18.2218784,\n        28.3859403,\n        28.3818327,\n    ],\n    dtype=np.float64,\n)\n\ndec_deg = np.array(\n    [\n        20.0550441,\n        23.5516817,\n        26.5139615,\n        23.5525348,\n        26.5160622,\n        23.5555991,\n        20.1218532,\n        20.1264229,\n        20.1275173,\n        23.6064063,\n        26.6622284,\n        23.6270392,\n        23.6272157,\n        20.2977473,\n        26.8303010,\n        26.9256271,\n        20.7096409,\n        27.1602652,\n        27.1606420,\n    ],\n    dtype=np.float64,\n)\n\njd_utc = np.array(\n    [\n        2458789.6362963,\n        2458789.6381250,\n        2458789.6381250,\n        2458789.6663773,\n        2458789.6663773,\n        2458789.7706481,\n        2458790.6995023,\n        2458790.7733333,\n        2458790.7914120,\n        2458791.8445602,\n        2458791.8445602,\n        2458792.8514699,\n        2458792.8590741,\n        2458793.6896759,\n        2458794.7996759,\n        2458796.7965162,\n        2458801.7863426,\n        2458803.7699537,\n        2458803.7875231,\n    ],\n    dtype=np.float64,\n)\n# Convert times to MJD (TT) using astropy\nt_utc = Time(jd_utc, format=\"jd\", scale=\"utc\")\nmjd_tt = t_utc.tt.mjd.astype(np.float64)\n\n\nts = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg,\n    dec_deg,\n    error_ra_arcsec=0.3,\n    error_dec_arcsec=0.3,\n    mjd_tt=mjd_tt,\n    observer=obs,\n)\n\nparams = IODParams.builder().max_triplets(100).do_sequential().build()\nok, errors = ts.estimate_all_orbits(env, params, seed=42)\n\nprint(\"ok keys:\", list(ok.keys()))\nprint(\"errors:\", errors)\n</code></pre> <p>Notes</p> <ul> <li>In sequential mode, pressing Ctrl\u2011C returns partial results collected so far.</li> <li>If <code>.do_parallel()</code> is enabled in <code>IODParams</code>, cancellation is not available.</li> <li>Set <code>seed</code> for deterministic noise sampling and triplet exploration.</li> </ul>"},{"location":"tutorials/trajectories_tuto/#one-trajectory-only","title":"One trajectory only","text":"<p>Use the dict\u2011like access to get an <code>Observations</code> view, then call its single\u2011object API.</p> Single trajectory IOD<pre><code># Single-trajectory estimation using an Observations view\nfrom py_outfit import PyOutfit, TrajectorySet, IODParams, Observer\nimport numpy as np\nfrom astropy.time import Time\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\nobs = Observer(\n    0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3 / 3600.0), np.deg2rad(0.3 / 3600.0)\n)\nenv.add_observer(obs)\n\ntrajectory_id = np.array(\n    [0, 1, 2, 1, 2, 1, 0, 0, 0, 1, 2, 1, 1, 0, 2, 2, 0, 2, 2],\n    dtype=np.uint32,\n)\n\nra_deg = np.array(\n    [\n        20.9191548,\n        33.4247141,\n        32.1435128,\n        33.4159091,\n        32.1347282,\n        33.3829299,\n        20.6388309,\n        20.6187259,\n        20.6137886,\n        32.7525147,\n        31.4874917,\n        32.4518231,\n        32.4495403,\n        19.8927380,\n        30.6416348,\n        30.0938936,\n        18.2218784,\n        28.3859403,\n        28.3818327,\n    ],\n    dtype=np.float64,\n)\n\ndec_deg = np.array(\n    [\n        20.0550441,\n        23.5516817,\n        26.5139615,\n        23.5525348,\n        26.5160622,\n        23.5555991,\n        20.1218532,\n        20.1264229,\n        20.1275173,\n        23.6064063,\n        26.6622284,\n        23.6270392,\n        23.6272157,\n        20.2977473,\n        26.8303010,\n        26.9256271,\n        20.7096409,\n        27.1602652,\n        27.1606420,\n    ],\n    dtype=np.float64,\n)\n\njd_utc = np.array(\n    [\n        2458789.6362963,\n        2458789.6381250,\n        2458789.6381250,\n        2458789.6663773,\n        2458789.6663773,\n        2458789.7706481,\n        2458790.6995023,\n        2458790.7733333,\n        2458790.7914120,\n        2458791.8445602,\n        2458791.8445602,\n        2458792.8514699,\n        2458792.8590741,\n        2458793.6896759,\n        2458794.7996759,\n        2458796.7965162,\n        2458801.7863426,\n        2458803.7699537,\n        2458803.7875231,\n    ],\n    dtype=np.float64,\n)\n# Convert times to MJD (TT) using astropy\nt_utc = Time(jd_utc, format=\"jd\", scale=\"utc\")\nmjd_tt = t_utc.tt.mjd.astype(np.float64)\n\nts = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg,\n    dec_deg,\n    error_ra_arcsec=0.3,\n    error_dec_arcsec=0.3,\n    mjd_tt=mjd_tt,\n    observer=obs,\n)\n\nparams = IODParams.builder().max_triplets(100).build()\n\n# Pick the first key in this tiny example\nkey = ts.keys()[0]\nobs_view = ts[key]\nres, rms = obs_view.estimate_best_orbit(env, params, seed=123)\nprint(\"result:\", key, rms, res)\n</code></pre>"},{"location":"tutorials/trajectories_tuto/#caveats-and-reproducibility","title":"Caveats and reproducibility","text":"<ul> <li>Known caveat: due to an upstream issue in the backend\u2019s batch RMS correction, per\u2011observation uncertainties may be modified in place during a run. Calling <code>estimate_best_orbit</code> multiple times on the same <code>Observations</code> instance can yield different RMS values across calls. As a temporary workaround, recreate the <code>Observations</code> (or <code>TrajectorySet</code>) before each repeated estimation when you need strict reproducibility.</li> <li>Providing a <code>seed</code> makes noise sampling deterministic but does not prevent such in\u2011place mutations.</li> </ul>"},{"location":"tutorials/trajectories_tuto/#see-also","title":"See also","text":"<ul> <li>API reference: <code>py_outfit.trajectories.TrajectorySet</code></li> <li>Configuration: <code>IODParams</code> tutorial for tuning Gauss IOD</li> <li>High\u2011level snippet used in examples:</li> </ul> Overview<pre><code># High-level interaction between environment and trajectories\nfrom py_outfit import PyOutfit, IODParams, TrajectorySet, Observer\nimport numpy as np\nfrom astropy.time import Time\n\nenv = PyOutfit(\"horizon:DE440\", \"FCCT14\")\nobs = Observer(\n    0.0, 0.0, 1.0, \"DemoSite\", np.deg2rad(0.3 / 3600.0), np.deg2rad(0.3 / 3600.0)\n)\nenv.add_observer(obs)\n\n# Synthetic arrays for two trajectories (IDs 10 and 11)\ntrajectory_id = np.array(\n    [0, 1, 2, 1, 2, 1, 0, 0, 0, 1, 2, 1, 1, 0, 2, 2, 0, 2, 2, 10, 10, 10, 11, 11, 11],\n    dtype=np.uint32,\n)\nra_deg = np.array(\n    [\n        20.9191548,\n        33.4247141,\n        32.1435128,\n        33.4159091,\n        32.1347282,\n        33.3829299,\n        20.6388309,\n        20.6187259,\n        20.6137886,\n        32.7525147,\n        31.4874917,\n        32.4518231,\n        32.4495403,\n        19.8927380,\n        30.6416348,\n        30.0938936,\n        18.2218784,\n        28.3859403,\n        28.3818327,\n        10.0,\n        10.01,\n        10.02,\n        180.0,\n        180.02,\n        180.05,\n    ]\n)\ndec_deg = np.array(\n    [\n        20.0550441,\n        23.5516817,\n        26.5139615,\n        23.5525348,\n        26.5160622,\n        23.5555991,\n        20.1218532,\n        20.1264229,\n        20.1275173,\n        23.6064063,\n        26.6622284,\n        23.6270392,\n        23.6272157,\n        20.2977473,\n        26.8303010,\n        26.9256271,\n        20.7096409,\n        27.1602652,\n        27.1606420,\n        5.0,\n        5.01,\n        5.015,\n        -10.0,\n        -10.02,\n        -10.03,\n    ]\n)\ntimes_jd_utc = np.array(\n    [\n        2458789.6362963,\n        2458789.6381250,\n        2458789.6381250,\n        2458789.6663773,\n        2458789.6663773,\n        2458789.7706481,\n        2458790.6995023,\n        2458790.7733333,\n        2458790.7914120,\n        2458791.8445602,\n        2458791.8445602,\n        2458792.8514699,\n        2458792.8590741,\n        2458793.6896759,\n        2458794.7996759,\n        2458796.7965162,\n        2458801.7863426,\n        2458803.7699537,\n        2458803.7875231,\n        2458800.0,\n        2458800.01,\n        2458800.03,\n        2458800.0,\n        2458800.02,\n        2458800.05,\n    ]\n)\n\n# Convert times to MJD (TT) using astropy\nt_utc = Time(times_jd_utc, format=\"jd\", scale=\"utc\")\nmjd_tt = t_utc.tt.mjd.astype(np.float64)\n\n# Degree path performs a single conversion to radians at ingestion\nts = TrajectorySet.from_numpy_degrees(\n    env,\n    trajectory_id,\n    ra_deg,\n    dec_deg,\n    error_ra_arcsec=0.3,\n    error_dec_arcsec=0.3,\n    mjd_tt=mjd_tt,\n    observer=obs,\n)\n\n# Configure IOD and run batch estimation\nparams = IODParams.builder().max_triplets(200).do_sequential().build()\nok, errors = ts.estimate_all_orbits(env, params, seed=42)\n\nprint(\n    \"Trajectories:\", ts.number_of_trajectories(), \"Total obs:\", ts.total_observations()\n)\nprint(\"Success keys:\", list(ok.keys()))\nprint(\"Errors:\", errors)\n</code></pre>"}]}